//
// Generated by Bluespec Compiler, version 2022.01-36-ga6304315 (build a6304315)
//
// On Tue Oct  4 10:37:18 CEST 2022
//
//
// Ports:
// Name                         I/O  size props
// slave_awready                  O     1 reg
// slave_wready                   O     1 reg
// slave_bvalid                   O     1 reg
// slave_bresp                    O     2 reg
// slave_arready                  O     1 reg
// slave_rvalid                   O     1 reg
// slave_rresp                    O     2 reg
// slave_rdata                    O    32 reg
// io_scl_out                     O     1 reg
// io_scl_out_en                  O     1
// io_sda_out                     O     1 reg
// io_sda_out_en                  O     1
// isint                          O     1
// RDY_isint                      O     1 const
// timerint                       O     1 reg
// RDY_timerint                   O     1 const
// isber                          O     1 reg
// RDY_isber                      O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// slave_m_awvalid_awvalid        I     1
// slave_m_awvalid_awaddr         I    32 reg
// slave_m_awvalid_awsize         I     2 reg
// slave_m_awvalid_awprot         I     3 reg
// slave_m_wvalid_wvalid          I     1
// slave_m_wvalid_wdata           I    32 reg
// slave_m_wvalid_wstrb           I     4 reg
// slave_m_bready_bready          I     1
// slave_m_arvalid_arvalid        I     1
// slave_m_arvalid_araddr         I    32 reg
// slave_m_arvalid_arsize         I     2 reg
// slave_m_arvalid_arprot         I     3 reg
// slave_m_rready_rready          I     1
// io_scl_in_in                   I     1 reg
// io_sda_in_in                   I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mki2c(CLK,
	     RST_N,

	     slave_m_awvalid_awvalid,
	     slave_m_awvalid_awaddr,
	     slave_m_awvalid_awsize,
	     slave_m_awvalid_awprot,

	     slave_awready,

	     slave_m_wvalid_wvalid,
	     slave_m_wvalid_wdata,
	     slave_m_wvalid_wstrb,

	     slave_wready,

	     slave_bvalid,

	     slave_bresp,

	     slave_m_bready_bready,

	     slave_m_arvalid_arvalid,
	     slave_m_arvalid_araddr,
	     slave_m_arvalid_arsize,
	     slave_m_arvalid_arprot,

	     slave_arready,

	     slave_rvalid,

	     slave_rresp,

	     slave_rdata,

	     slave_m_rready_rready,

	     io_scl_out,

	     io_scl_in_in,

	     io_scl_out_en,

	     io_sda_out,

	     io_sda_in_in,

	     io_sda_out_en,

	     isint,
	     RDY_isint,

	     timerint,
	     RDY_timerint,

	     isber,
	     RDY_isber);
  input  CLK;
  input  RST_N;

  // action method slave_m_awvalid
  input  slave_m_awvalid_awvalid;
  input  [31 : 0] slave_m_awvalid_awaddr;
  input  [1 : 0] slave_m_awvalid_awsize;
  input  [2 : 0] slave_m_awvalid_awprot;

  // value method slave_m_awready
  output slave_awready;

  // action method slave_m_wvalid
  input  slave_m_wvalid_wvalid;
  input  [31 : 0] slave_m_wvalid_wdata;
  input  [3 : 0] slave_m_wvalid_wstrb;

  // value method slave_m_wready
  output slave_wready;

  // value method slave_m_bvalid
  output slave_bvalid;

  // value method slave_m_bresp
  output [1 : 0] slave_bresp;

  // value method slave_m_buser

  // action method slave_m_bready
  input  slave_m_bready_bready;

  // action method slave_m_arvalid
  input  slave_m_arvalid_arvalid;
  input  [31 : 0] slave_m_arvalid_araddr;
  input  [1 : 0] slave_m_arvalid_arsize;
  input  [2 : 0] slave_m_arvalid_arprot;

  // value method slave_m_arready
  output slave_arready;

  // value method slave_m_rvalid
  output slave_rvalid;

  // value method slave_m_rresp
  output [1 : 0] slave_rresp;

  // value method slave_m_rdata
  output [31 : 0] slave_rdata;

  // value method slave_m_ruser

  // action method slave_m_rready
  input  slave_m_rready_rready;

  // value method io_scl_out
  output io_scl_out;

  // action method io_scl_in
  input  io_scl_in_in;

  // value method io_scl_out_en
  output io_scl_out_en;

  // value method io_sda_out
  output io_sda_out;

  // action method io_sda_in
  input  io_sda_in_in;

  // value method io_sda_out_en
  output io_sda_out_en;

  // value method isint
  output isint;
  output RDY_isint;

  // value method timerint
  output timerint;
  output RDY_timerint;

  // value method isber
  output isber;
  output RDY_isber;

  // signals for module outputs
  wire [31 : 0] slave_rdata;
  wire [1 : 0] slave_bresp, slave_rresp;
  wire RDY_isber,
       RDY_isint,
       RDY_timerint,
       io_scl_out,
       io_scl_out_en,
       io_sda_out,
       io_sda_out_en,
       isber,
       isint,
       slave_arready,
       slave_awready,
       slave_bvalid,
       slave_rvalid,
       slave_wready,
       timerint;

  // register i2c_user_aas
  reg i2c_user_aas;
  wire i2c_user_aas_D_IN, i2c_user_aas_EN;

  // register i2c_user_ack
  reg i2c_user_ack;
  wire i2c_user_ack_D_IN, i2c_user_ack_EN;

  // register i2c_user_ad0_lrb
  reg i2c_user_ad0_lrb;
  wire i2c_user_ad0_lrb_D_IN, i2c_user_ad0_lrb_EN;

  // register i2c_user_bb
  reg i2c_user_bb;
  wire i2c_user_bb_D_IN, i2c_user_bb_EN;

  // register i2c_user_ber
  reg i2c_user_ber;
  reg i2c_user_ber_D_IN;
  wire i2c_user_ber_EN;

  // register i2c_user_cOutEn
  reg i2c_user_cOutEn;
  wire i2c_user_cOutEn_D_IN, i2c_user_cOutEn_EN;

  // register i2c_user_c_scl
  reg [31 : 0] i2c_user_c_scl;
  wire [31 : 0] i2c_user_c_scl_D_IN;
  wire i2c_user_c_scl_EN;

  // register i2c_user_coSCL
  reg [31 : 0] i2c_user_coSCL;
  reg [31 : 0] i2c_user_coSCL_D_IN;
  wire i2c_user_coSCL_EN;

  // register i2c_user_configchange
  reg i2c_user_configchange;
  wire i2c_user_configchange_D_IN, i2c_user_configchange_EN;

  // register i2c_user_cprescaler
  reg [7 : 0] i2c_user_cprescaler;
  wire [7 : 0] i2c_user_cprescaler_D_IN;
  wire i2c_user_cprescaler_EN;

  // register i2c_user_cycwaste
  reg [9 : 0] i2c_user_cycwaste;
  reg [9 : 0] i2c_user_cycwaste_D_IN;
  wire i2c_user_cycwaste_EN;

  // register i2c_user_dOutEn
  reg i2c_user_dOutEn;
  reg i2c_user_dOutEn_D_IN;
  wire i2c_user_dOutEn_EN;

  // register i2c_user_dataBit
  reg [3 : 0] i2c_user_dataBit;
  reg [3 : 0] i2c_user_dataBit_D_IN;
  wire i2c_user_dataBit_EN;

  // register i2c_user_drv0_rg
  reg [7 : 0] i2c_user_drv0_rg;
  wire [7 : 0] i2c_user_drv0_rg_D_IN;
  wire i2c_user_drv0_rg_EN;

  // register i2c_user_drv1_rg
  reg [7 : 0] i2c_user_drv1_rg;
  wire [7 : 0] i2c_user_drv1_rg_D_IN;
  wire i2c_user_drv1_rg_EN;

  // register i2c_user_drv2_rg
  reg [7 : 0] i2c_user_drv2_rg;
  wire [7 : 0] i2c_user_drv2_rg_D_IN;
  wire i2c_user_drv2_rg_EN;

  // register i2c_user_eni
  reg i2c_user_eni;
  wire i2c_user_eni_D_IN, i2c_user_eni_EN;

  // register i2c_user_es1
  reg i2c_user_es1;
  wire i2c_user_es1_D_IN, i2c_user_es1_EN;

  // register i2c_user_es2
  reg i2c_user_es2;
  wire i2c_user_es2_D_IN, i2c_user_es2_EN;

  // register i2c_user_eso
  reg i2c_user_eso;
  wire i2c_user_eso_D_IN, i2c_user_eso_EN;

  // register i2c_user_i2ctime
  reg [15 : 0] i2c_user_i2ctime;
  wire [15 : 0] i2c_user_i2ctime_D_IN;
  wire i2c_user_i2ctime_EN;

  // register i2c_user_i2ctimeout
  reg [13 : 0] i2c_user_i2ctimeout;
  wire [13 : 0] i2c_user_i2ctimeout_D_IN;
  wire i2c_user_i2ctimeout_EN;

  // register i2c_user_lab
  reg i2c_user_lab;
  wire i2c_user_lab_D_IN, i2c_user_lab_EN;

  // register i2c_user_last_byte_read
  reg i2c_user_last_byte_read;
  wire i2c_user_last_byte_read_D_IN, i2c_user_last_byte_read_EN;

  // register i2c_user_mTransFSM
  reg [4 : 0] i2c_user_mTransFSM;
  reg [4 : 0] i2c_user_mTransFSM_D_IN;
  wire i2c_user_mTransFSM_EN;

  // register i2c_user_mod_start
  reg i2c_user_mod_start;
  wire i2c_user_mod_start_D_IN, i2c_user_mod_start_EN;

  // register i2c_user_operation
  reg i2c_user_operation;
  wire i2c_user_operation_D_IN, i2c_user_operation_EN;

  // register i2c_user_pd_rg
  reg [7 : 0] i2c_user_pd_rg;
  wire [7 : 0] i2c_user_pd_rg_D_IN;
  wire i2c_user_pd_rg_EN;

  // register i2c_user_pin
  reg i2c_user_pin;
  reg i2c_user_pin_D_IN;
  wire i2c_user_pin_EN;

  // register i2c_user_ppen_rg
  reg [7 : 0] i2c_user_ppen_rg;
  wire [7 : 0] i2c_user_ppen_rg_D_IN;
  wire i2c_user_ppen_rg_EN;

  // register i2c_user_prg_slew_rg
  reg [7 : 0] i2c_user_prg_slew_rg;
  wire [7 : 0] i2c_user_prg_slew_rg_D_IN;
  wire i2c_user_prg_slew_rg_EN;

  // register i2c_user_puq_rg
  reg [7 : 0] i2c_user_puq_rg;
  wire [7 : 0] i2c_user_puq_rg_D_IN;
  wire i2c_user_puq_rg_EN;

  // register i2c_user_pwrup_pull_en_rg
  reg [7 : 0] i2c_user_pwrup_pull_en_rg;
  wire [7 : 0] i2c_user_pwrup_pull_en_rg_D_IN;
  wire i2c_user_pwrup_pull_en_rg_EN;

  // register i2c_user_pwrupzhl_rg
  reg [7 : 0] i2c_user_pwrupzhl_rg;
  wire [7 : 0] i2c_user_pwrupzhl_rg_D_IN;
  wire i2c_user_pwrupzhl_rg_EN;

  // register i2c_user_reSCL
  reg [31 : 0] i2c_user_reSCL;
  wire [31 : 0] i2c_user_reSCL_D_IN;
  wire i2c_user_reSCL_EN;

  // register i2c_user_resetcount
  reg [5 : 0] i2c_user_resetcount;
  wire [5 : 0] i2c_user_resetcount_D_IN;
  wire i2c_user_resetcount_EN;

  // register i2c_user_rprescaler
  reg [7 : 0] i2c_user_rprescaler;
  wire [7 : 0] i2c_user_rprescaler_D_IN;
  wire i2c_user_rprescaler_EN;

  // register i2c_user_rstsig
  reg i2c_user_rstsig;
  wire i2c_user_rstsig_D_IN, i2c_user_rstsig_EN;

  // register i2c_user_s0
  reg [7 : 0] i2c_user_s0;
  wire [7 : 0] i2c_user_s0_D_IN;
  wire i2c_user_s0_EN;

  // register i2c_user_s01
  reg [7 : 0] i2c_user_s01;
  wire [7 : 0] i2c_user_s01_D_IN;
  wire i2c_user_s01_EN;

  // register i2c_user_s2
  reg [7 : 0] i2c_user_s2;
  wire [7 : 0] i2c_user_s2_D_IN;
  wire i2c_user_s2_EN;

  // register i2c_user_s3
  reg [7 : 0] i2c_user_s3;
  reg [7 : 0] i2c_user_s3_D_IN;
  wire i2c_user_s3_EN;

  // register i2c_user_scl_start
  reg i2c_user_scl_start;
  wire i2c_user_scl_start_D_IN, i2c_user_scl_start_EN;

  // register i2c_user_sendInd
  reg [1 : 0] i2c_user_sendInd;
  reg [1 : 0] i2c_user_sendInd_D_IN;
  wire i2c_user_sendInd_EN;

  // register i2c_user_st_toggle
  reg i2c_user_st_toggle;
  reg i2c_user_st_toggle_D_IN;
  wire i2c_user_st_toggle_EN;

  // register i2c_user_sta
  reg i2c_user_sta;
  wire i2c_user_sta_D_IN, i2c_user_sta_EN;

  // register i2c_user_sto
  reg i2c_user_sto;
  wire i2c_user_sto_D_IN, i2c_user_sto_EN;

  // register i2c_user_sts
  reg i2c_user_sts;
  wire i2c_user_sts_D_IN, i2c_user_sts_EN;

  // register i2c_user_val_SCL
  reg i2c_user_val_SCL;
  wire i2c_user_val_SCL_D_IN, i2c_user_val_SCL_EN;

  // register i2c_user_val_SCL_in
  reg i2c_user_val_SCL_in;
  wire i2c_user_val_SCL_in_D_IN, i2c_user_val_SCL_in_EN;

  // register i2c_user_val_SDA
  reg i2c_user_val_SDA;
  reg i2c_user_val_SDA_D_IN;
  wire i2c_user_val_SDA_EN;

  // register i2c_user_val_SDA_in
  reg i2c_user_val_SDA_in;
  wire i2c_user_val_SDA_in_D_IN, i2c_user_val_SDA_in_EN;

  // register i2c_user_zero
  reg i2c_user_zero;
  wire i2c_user_zero_D_IN, i2c_user_zero_EN;

  // ports of submodule s_xactor_f_rd_addr
  wire [36 : 0] s_xactor_f_rd_addr_D_IN, s_xactor_f_rd_addr_D_OUT;
  wire s_xactor_f_rd_addr_CLR,
       s_xactor_f_rd_addr_DEQ,
       s_xactor_f_rd_addr_EMPTY_N,
       s_xactor_f_rd_addr_ENQ,
       s_xactor_f_rd_addr_FULL_N;

  // ports of submodule s_xactor_f_rd_data
  wire [33 : 0] s_xactor_f_rd_data_D_IN, s_xactor_f_rd_data_D_OUT;
  wire s_xactor_f_rd_data_CLR,
       s_xactor_f_rd_data_DEQ,
       s_xactor_f_rd_data_EMPTY_N,
       s_xactor_f_rd_data_ENQ,
       s_xactor_f_rd_data_FULL_N;

  // ports of submodule s_xactor_f_wr_addr
  wire [36 : 0] s_xactor_f_wr_addr_D_IN, s_xactor_f_wr_addr_D_OUT;
  wire s_xactor_f_wr_addr_CLR,
       s_xactor_f_wr_addr_DEQ,
       s_xactor_f_wr_addr_EMPTY_N,
       s_xactor_f_wr_addr_ENQ,
       s_xactor_f_wr_addr_FULL_N;

  // ports of submodule s_xactor_f_wr_data
  wire [35 : 0] s_xactor_f_wr_data_D_IN, s_xactor_f_wr_data_D_OUT;
  wire s_xactor_f_wr_data_CLR,
       s_xactor_f_wr_data_DEQ,
       s_xactor_f_wr_data_EMPTY_N,
       s_xactor_f_wr_data_ENQ,
       s_xactor_f_wr_data_FULL_N;

  // ports of submodule s_xactor_f_wr_resp
  wire [1 : 0] s_xactor_f_wr_resp_D_IN, s_xactor_f_wr_resp_D_OUT;
  wire s_xactor_f_wr_resp_CLR,
       s_xactor_f_wr_resp_DEQ,
       s_xactor_f_wr_resp_EMPTY_N,
       s_xactor_f_wr_resp_ENQ,
       s_xactor_f_wr_resp_FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_i2c_user_check_Ack,
       CAN_FIRE_RL_i2c_user_check_control_reg,
       CAN_FIRE_RL_i2c_user_count_scl,
       CAN_FIRE_RL_i2c_user_idler,
       CAN_FIRE_RL_i2c_user_receive_data,
       CAN_FIRE_RL_i2c_user_receive_data1,
       CAN_FIRE_RL_i2c_user_reset_state,
       CAN_FIRE_RL_i2c_user_resetfilter,
       CAN_FIRE_RL_i2c_user_restore_scl,
       CAN_FIRE_RL_i2c_user_send_addr,
       CAN_FIRE_RL_i2c_user_send_data,
       CAN_FIRE_RL_i2c_user_send_rtstart_trans,
       CAN_FIRE_RL_i2c_user_send_start_trans,
       CAN_FIRE_RL_i2c_user_send_stop_condition,
       CAN_FIRE_RL_i2c_user_set_i2c_clock,
       CAN_FIRE_RL_i2c_user_set_scl_clock,
       CAN_FIRE_RL_i2c_user_toggle_scl,
       CAN_FIRE_RL_i2c_user_wait_interrupt,
       CAN_FIRE_RL_i2c_user_wait_interrupt_receive_end,
       CAN_FIRE_RL_read_request,
       CAN_FIRE_RL_write_request,
       CAN_FIRE___me_check_1,
       CAN_FIRE___me_check_10,
       CAN_FIRE___me_check_11,
       CAN_FIRE___me_check_13,
       CAN_FIRE___me_check_2,
       CAN_FIRE___me_check_6,
       CAN_FIRE_io_scl_in,
       CAN_FIRE_io_sda_in,
       CAN_FIRE_slave_m_arvalid,
       CAN_FIRE_slave_m_awvalid,
       CAN_FIRE_slave_m_bready,
       CAN_FIRE_slave_m_rready,
       CAN_FIRE_slave_m_wvalid,
       WILL_FIRE_RL_i2c_user_check_Ack,
       WILL_FIRE_RL_i2c_user_check_control_reg,
       WILL_FIRE_RL_i2c_user_count_scl,
       WILL_FIRE_RL_i2c_user_idler,
       WILL_FIRE_RL_i2c_user_receive_data,
       WILL_FIRE_RL_i2c_user_receive_data1,
       WILL_FIRE_RL_i2c_user_reset_state,
       WILL_FIRE_RL_i2c_user_resetfilter,
       WILL_FIRE_RL_i2c_user_restore_scl,
       WILL_FIRE_RL_i2c_user_send_addr,
       WILL_FIRE_RL_i2c_user_send_data,
       WILL_FIRE_RL_i2c_user_send_rtstart_trans,
       WILL_FIRE_RL_i2c_user_send_start_trans,
       WILL_FIRE_RL_i2c_user_send_stop_condition,
       WILL_FIRE_RL_i2c_user_set_i2c_clock,
       WILL_FIRE_RL_i2c_user_set_scl_clock,
       WILL_FIRE_RL_i2c_user_toggle_scl,
       WILL_FIRE_RL_i2c_user_wait_interrupt,
       WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end,
       WILL_FIRE_RL_read_request,
       WILL_FIRE_RL_write_request,
       WILL_FIRE___me_check_1,
       WILL_FIRE___me_check_10,
       WILL_FIRE___me_check_11,
       WILL_FIRE___me_check_13,
       WILL_FIRE___me_check_2,
       WILL_FIRE___me_check_6,
       WILL_FIRE_io_scl_in,
       WILL_FIRE_io_sda_in,
       WILL_FIRE_slave_m_arvalid,
       WILL_FIRE_slave_m_awvalid,
       WILL_FIRE_slave_m_bready,
       WILL_FIRE_slave_m_rready,
       WILL_FIRE_slave_m_wvalid;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_i2c_user_coSCL_write_1__VAL_3;
  wire [15 : 0] MUX_i2c_user_i2ctime_write_1__VAL_2;
  wire [13 : 0] MUX_i2c_user_i2ctimeout_write_1__VAL_3;
  wire [7 : 0] MUX_i2c_user_s0_write_1__VAL_2, MUX_i2c_user_s3_write_1__VAL_5;
  wire [5 : 0] MUX_i2c_user_resetcount_write_1__VAL_2;
  wire [4 : 0] MUX_i2c_user_mTransFSM_write_1__VAL_10,
	       MUX_i2c_user_mTransFSM_write_1__VAL_5,
	       MUX_i2c_user_mTransFSM_write_1__VAL_6,
	       MUX_i2c_user_mTransFSM_write_1__VAL_7,
	       MUX_i2c_user_mTransFSM_write_1__VAL_9;
  wire [1 : 0] MUX_i2c_user_sendInd_write_1__VAL_1;
  wire MUX_i2c_user_aas_write_1__SEL_1,
       MUX_i2c_user_ack_write_1__SEL_1,
       MUX_i2c_user_ack_write_1__VAL_1,
       MUX_i2c_user_ad0_lrb_write_1__SEL_2,
       MUX_i2c_user_ad0_lrb_write_1__VAL_2,
       MUX_i2c_user_bb_write_1__PSEL_2,
       MUX_i2c_user_bb_write_1__SEL_2,
       MUX_i2c_user_ber_write_1__SEL_1,
       MUX_i2c_user_ber_write_1__SEL_3,
       MUX_i2c_user_ber_write_1__SEL_4,
       MUX_i2c_user_ber_write_1__SEL_5,
       MUX_i2c_user_ber_write_1__SEL_6,
       MUX_i2c_user_ber_write_1__SEL_8,
       MUX_i2c_user_cOutEn_write_1__SEL_1,
       MUX_i2c_user_cOutEn_write_1__SEL_2,
       MUX_i2c_user_configchange_write_1__SEL_1,
       MUX_i2c_user_dOutEn_write_1__PSEL_1,
       MUX_i2c_user_dOutEn_write_1__SEL_1,
       MUX_i2c_user_dOutEn_write_1__SEL_2,
       MUX_i2c_user_dOutEn_write_1__SEL_6,
       MUX_i2c_user_dOutEn_write_1__VAL_6,
       MUX_i2c_user_dataBit_write_1__SEL_1,
       MUX_i2c_user_dataBit_write_1__SEL_2,
       MUX_i2c_user_dataBit_write_1__SEL_4,
       MUX_i2c_user_dataBit_write_1__SEL_5,
       MUX_i2c_user_dataBit_write_1__SEL_7,
       MUX_i2c_user_eso_write_1__VAL_1,
       MUX_i2c_user_i2ctime_write_1__SEL_1,
       MUX_i2c_user_i2ctime_write_1__SEL_2,
       MUX_i2c_user_i2ctimeout_write_1__SEL_2,
       MUX_i2c_user_i2ctimeout_write_1__SEL_3,
       MUX_i2c_user_last_byte_read_write_1__SEL_1,
       MUX_i2c_user_mTransFSM_write_1__SEL_11,
       MUX_i2c_user_mTransFSM_write_1__SEL_13,
       MUX_i2c_user_mTransFSM_write_1__SEL_2,
       MUX_i2c_user_mTransFSM_write_1__SEL_3,
       MUX_i2c_user_mTransFSM_write_1__SEL_6,
       MUX_i2c_user_mTransFSM_write_1__SEL_8,
       MUX_i2c_user_mTransFSM_write_1__SEL_9,
       MUX_i2c_user_mod_start_write_1__SEL_1,
       MUX_i2c_user_pin_write_1__SEL_2,
       MUX_i2c_user_pin_write_1__SEL_4,
       MUX_i2c_user_pin_write_1__SEL_6,
       MUX_i2c_user_pin_write_1__VAL_2,
       MUX_i2c_user_reSCL_write_1__SEL_1,
       MUX_i2c_user_s0_write_1__SEL_1,
       MUX_i2c_user_s3_write_1__SEL_2,
       MUX_i2c_user_sendInd_write_1__SEL_1,
       MUX_i2c_user_sendInd_write_1__SEL_5,
       MUX_i2c_user_sendInd_write_1__SEL_6,
       MUX_i2c_user_st_toggle_write_1__SEL_2,
       MUX_i2c_user_st_toggle_write_1__SEL_3,
       MUX_i2c_user_val_SCL_write_1__SEL_1,
       MUX_i2c_user_val_SDA_write_1__SEL_1,
       MUX_i2c_user_val_SDA_write_1__SEL_6,
       MUX_i2c_user_val_SDA_write_1__SEL_7,
       MUX_i2c_user_val_SDA_write_1__VAL_1,
       MUX_i2c_user_val_SDA_write_1__VAL_5,
       MUX_i2c_user_val_SDA_write_1__VAL_7;

  // remaining internal signals
  reg [31 : 0] IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246;
  reg [4 : 0] CASE_x214_1_15_2_9_IF_i2c_user_s3_EQ_0xA_THEN__ETC__q1;
  wire [31 : 0] b__h7832,
		b__h7839,
		b__h7846,
		b__h7853,
		b__h7860,
		b__h7867,
		b__h7874;
  wire [13 : 0] x__h5910;
  wire [9 : 0] x__h2667;
  wire [7 : 0] x__h6819, y__h6860;
  wire [6 : 0] r1__read__h8341, r1__read__h8928;
  wire [5 : 0] r1__read__h8343, r1__read__h8930, x__h6890;
  wire [4 : 0] IF_s_xactor_f_wr_data_first__56_BITS_6_TO_5_57_ETC___d278,
	       r1__read__h8345,
	       r1__read__h8932;
  wire [3 : 0] r1__read__h8347, r1__read__h8934, x__h6839;
  wire [2 : 0] _0b110__q2, _0b1__q3, r1__read__h8349, r1__read__h8936;
  wire [1 : 0] r1__read__h8351, r1__read__h8938, x__h3214;
  wire NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d128,
       NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d139,
       i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101,
       i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d125,
       i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d133,
       i2c_user_pin_3_AND_i2c_user_sta_1_CONCAT_i2c_u_ETC___d115,
       s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d274,
       s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283,
       s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300,
       s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d303,
       x__h14021,
       x__h6744;

  // action method slave_m_awvalid
  assign CAN_FIRE_slave_m_awvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_awvalid = 1'd1 ;

  // value method slave_m_awready
  assign slave_awready = s_xactor_f_wr_addr_FULL_N ;

  // action method slave_m_wvalid
  assign CAN_FIRE_slave_m_wvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_wvalid = 1'd1 ;

  // value method slave_m_wready
  assign slave_wready = s_xactor_f_wr_data_FULL_N ;

  // value method slave_m_bvalid
  assign slave_bvalid = s_xactor_f_wr_resp_EMPTY_N ;

  // value method slave_m_bresp
  assign slave_bresp = s_xactor_f_wr_resp_D_OUT ;

  // action method slave_m_bready
  assign CAN_FIRE_slave_m_bready = 1'd1 ;
  assign WILL_FIRE_slave_m_bready = 1'd1 ;

  // action method slave_m_arvalid
  assign CAN_FIRE_slave_m_arvalid = 1'd1 ;
  assign WILL_FIRE_slave_m_arvalid = 1'd1 ;

  // value method slave_m_arready
  assign slave_arready = s_xactor_f_rd_addr_FULL_N ;

  // value method slave_m_rvalid
  assign slave_rvalid = s_xactor_f_rd_data_EMPTY_N ;

  // value method slave_m_rresp
  assign slave_rresp = s_xactor_f_rd_data_D_OUT[33:32] ;

  // value method slave_m_rdata
  assign slave_rdata = s_xactor_f_rd_data_D_OUT[31:0] ;

  // action method slave_m_rready
  assign CAN_FIRE_slave_m_rready = 1'd1 ;
  assign WILL_FIRE_slave_m_rready = 1'd1 ;

  // value method io_scl_out
  assign io_scl_out = i2c_user_val_SCL ;

  // action method io_scl_in
  assign CAN_FIRE_io_scl_in = 1'd1 ;
  assign WILL_FIRE_io_scl_in = 1'd1 ;

  // value method io_scl_out_en
  assign io_scl_out_en = i2c_user_cOutEn && i2c_user_eso ;

  // value method io_sda_out
  assign io_sda_out = i2c_user_val_SDA ;

  // action method io_sda_in
  assign CAN_FIRE_io_sda_in = 1'd1 ;
  assign WILL_FIRE_io_sda_in = 1'd1 ;

  // value method io_sda_out_en
  assign io_sda_out_en = i2c_user_dOutEn && i2c_user_eso ;

  // value method isint
  assign isint = x__h14021 & i2c_user_eni ;
  assign RDY_isint = 1'd1 ;

  // value method timerint
  assign timerint = i2c_user_i2ctime[15] ;
  assign RDY_timerint = 1'd1 ;

  // value method isber
  assign isber = i2c_user_ber ;
  assign RDY_isber = 1'd1 ;

  // submodule s_xactor_f_rd_addr
  FIFO2 #(.width(32'd37), .guarded(1'd1)) s_xactor_f_rd_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_rd_addr_D_IN),
							     .ENQ(s_xactor_f_rd_addr_ENQ),
							     .DEQ(s_xactor_f_rd_addr_DEQ),
							     .CLR(s_xactor_f_rd_addr_CLR),
							     .D_OUT(s_xactor_f_rd_addr_D_OUT),
							     .FULL_N(s_xactor_f_rd_addr_FULL_N),
							     .EMPTY_N(s_xactor_f_rd_addr_EMPTY_N));

  // submodule s_xactor_f_rd_data
  FIFO2 #(.width(32'd34), .guarded(1'd1)) s_xactor_f_rd_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_rd_data_D_IN),
							     .ENQ(s_xactor_f_rd_data_ENQ),
							     .DEQ(s_xactor_f_rd_data_DEQ),
							     .CLR(s_xactor_f_rd_data_CLR),
							     .D_OUT(s_xactor_f_rd_data_D_OUT),
							     .FULL_N(s_xactor_f_rd_data_FULL_N),
							     .EMPTY_N(s_xactor_f_rd_data_EMPTY_N));

  // submodule s_xactor_f_wr_addr
  FIFO2 #(.width(32'd37), .guarded(1'd1)) s_xactor_f_wr_addr(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_wr_addr_D_IN),
							     .ENQ(s_xactor_f_wr_addr_ENQ),
							     .DEQ(s_xactor_f_wr_addr_DEQ),
							     .CLR(s_xactor_f_wr_addr_CLR),
							     .D_OUT(s_xactor_f_wr_addr_D_OUT),
							     .FULL_N(s_xactor_f_wr_addr_FULL_N),
							     .EMPTY_N(s_xactor_f_wr_addr_EMPTY_N));

  // submodule s_xactor_f_wr_data
  FIFO2 #(.width(32'd36), .guarded(1'd1)) s_xactor_f_wr_data(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(s_xactor_f_wr_data_D_IN),
							     .ENQ(s_xactor_f_wr_data_ENQ),
							     .DEQ(s_xactor_f_wr_data_DEQ),
							     .CLR(s_xactor_f_wr_data_CLR),
							     .D_OUT(s_xactor_f_wr_data_D_OUT),
							     .FULL_N(s_xactor_f_wr_data_FULL_N),
							     .EMPTY_N(s_xactor_f_wr_data_EMPTY_N));

  // submodule s_xactor_f_wr_resp
  FIFO2 #(.width(32'd2), .guarded(1'd1)) s_xactor_f_wr_resp(.RST(RST_N),
							    .CLK(CLK),
							    .D_IN(s_xactor_f_wr_resp_D_IN),
							    .ENQ(s_xactor_f_wr_resp_ENQ),
							    .DEQ(s_xactor_f_wr_resp_DEQ),
							    .CLR(s_xactor_f_wr_resp_CLR),
							    .D_OUT(s_xactor_f_wr_resp_D_OUT),
							    .FULL_N(s_xactor_f_wr_resp_FULL_N),
							    .EMPTY_N(s_xactor_f_wr_resp_EMPTY_N));

  // rule RL_read_request
  assign CAN_FIRE_RL_read_request =
	     s_xactor_f_rd_addr_EMPTY_N && s_xactor_f_rd_data_FULL_N ;
  assign WILL_FIRE_RL_read_request = CAN_FIRE_RL_read_request ;

  // rule RL_i2c_user_set_i2c_clock
  //   This sets the module's operating frequency based on the values in s2 register
  //   Assuming Processor operates at 50MHz for now
  //   PreScaler is an approximation of the available values
  assign CAN_FIRE_RL_i2c_user_set_i2c_clock =
	     i2c_user_mod_start && !i2c_user_eso ;
  assign WILL_FIRE_RL_i2c_user_set_i2c_clock =
	     CAN_FIRE_RL_i2c_user_set_i2c_clock ;

  // rule RL_i2c_user_set_scl_clock
  //   This rule is used to select one of the SCL clock frequencies among the ones based on the s2 register encoding
  assign CAN_FIRE_RL_i2c_user_set_scl_clock =
	     i2c_user_scl_start && !i2c_user_eso ;
  assign WILL_FIRE_RL_i2c_user_set_scl_clock =
	     CAN_FIRE_RL_i2c_user_set_scl_clock ;

  // rule RL_i2c_user_count_scl
  //   This rule is used to count down SCL clock which is a scaled down version of the Module clock derived from the system clock. SCL toggles only during transmission. For Multiple masters, different scenarios might arise
  assign CAN_FIRE_RL_i2c_user_count_scl =
	     i2c_user_coSCL != 32'd0 && i2c_user_eso && i2c_user_st_toggle ;
  assign WILL_FIRE_RL_i2c_user_count_scl = CAN_FIRE_RL_i2c_user_count_scl ;

  // rule RL_i2c_user_restore_scl
  //   This rule is used to restore the SCL count value. Sending a tick, operating as scl clock
  assign CAN_FIRE_RL_i2c_user_restore_scl =
	     i2c_user_coSCL == 32'd0 && i2c_user_reSCL != 32'd0 ;
  assign WILL_FIRE_RL_i2c_user_restore_scl =
	     CAN_FIRE_RL_i2c_user_restore_scl ;

  // rule __me_check_1
  //   This rule is used to select one of the SCL clock frequencies among the ones based on the s2 register encoding
  assign CAN_FIRE___me_check_1 = 1'b1 ;
  assign WILL_FIRE___me_check_1 = 1'b1 ;

  // rule __me_check_2
  //   This rule is used to count down SCL clock which is a scaled down version of the Module clock derived from the system clock. SCL toggles only during transmission. For Multiple masters, different scenarios might arise
  assign CAN_FIRE___me_check_2 = 1'b1 ;
  assign WILL_FIRE___me_check_2 = 1'b1 ;

  // rule RL_i2c_user_idler
  assign CAN_FIRE_RL_i2c_user_idler = i2c_user_mTransFSM == 5'd1 ;
  assign WILL_FIRE_RL_i2c_user_idler =
	     CAN_FIRE_RL_i2c_user_idler && !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_send_start_trans
  //   Send Start bit to the Slave
  assign CAN_FIRE_RL_i2c_user_send_start_trans =
	     i2c_user_val_SCL_in && i2c_user_mTransFSM == 5'd2 &&
	     i2c_user_eso &&
	     i2c_user_bb ;
  assign WILL_FIRE_RL_i2c_user_send_start_trans =
	     CAN_FIRE_RL_i2c_user_send_start_trans &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_send_rtstart_trans
  assign CAN_FIRE_RL_i2c_user_send_rtstart_trans =
	     i2c_user_val_SCL_in && i2c_user_mTransFSM == 5'd4 &&
	     i2c_user_eso ;
  assign WILL_FIRE_RL_i2c_user_send_rtstart_trans =
	     CAN_FIRE_RL_i2c_user_send_rtstart_trans &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_send_addr
  //   Send Slave Address for Transaction
  assign CAN_FIRE_RL_i2c_user_send_addr =
	     i2c_user_mTransFSM == 5'd5 && CAN_FIRE_RL_i2c_user_restore_scl &&
	     i2c_user_eso &&
	     i2c_user_val_SCL ;
  assign WILL_FIRE_RL_i2c_user_send_addr =
	     CAN_FIRE_RL_i2c_user_send_addr &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_check_Ack
  assign CAN_FIRE_RL_i2c_user_check_Ack =
	     i2c_user_mTransFSM == 5'd11 &&
	     CAN_FIRE_RL_i2c_user_restore_scl &&
	     i2c_user_eso ;
  assign WILL_FIRE_RL_i2c_user_check_Ack =
	     CAN_FIRE_RL_i2c_user_check_Ack &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_wait_interrupt
  //   Wait for the generated interrupt to be serviced
  assign CAN_FIRE_RL_i2c_user_wait_interrupt =
	     i2c_user_mTransFSM == 5'd6 && i2c_user_eso &&
	     !i2c_user_val_SCL_in ;
  assign WILL_FIRE_RL_i2c_user_wait_interrupt =
	     CAN_FIRE_RL_i2c_user_wait_interrupt &&
	     !WILL_FIRE_RL_write_request &&
	     !WILL_FIRE_RL_read_request ;

  // rule RL_i2c_user_send_data
  //   Shift the 8-bit data through the SDA line at each low pulse of SCL
  assign CAN_FIRE_RL_i2c_user_send_data =
	     i2c_user_mTransFSM == 5'd7 && CAN_FIRE_RL_i2c_user_restore_scl &&
	     i2c_user_eso &&
	     i2c_user_val_SCL ;
  assign WILL_FIRE_RL_i2c_user_send_data =
	     CAN_FIRE_RL_i2c_user_send_data &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_receive_data
  //   Receive the 8-bit data through the SDA line at each high pulse of SCL
  assign CAN_FIRE_RL_i2c_user_receive_data =
	     i2c_user_mTransFSM == 5'd8 && CAN_FIRE_RL_i2c_user_restore_scl &&
	     i2c_user_eso &&
	     !i2c_user_val_SCL ;
  assign WILL_FIRE_RL_i2c_user_receive_data =
	     CAN_FIRE_RL_i2c_user_receive_data ;

  // rule __me_check_10
  //   Send Slave Address for Transaction
  assign CAN_FIRE___me_check_10 = 1'b1 ;
  assign WILL_FIRE___me_check_10 = 1'b1 ;

  // rule __me_check_11
  assign CAN_FIRE___me_check_11 = 1'b1 ;
  assign WILL_FIRE___me_check_11 = 1'b1 ;

  // rule __me_check_13
  //   Shift the 8-bit data through the SDA line at each low pulse of SCL
  assign CAN_FIRE___me_check_13 = 1'b1 ;
  assign WILL_FIRE___me_check_13 = 1'b1 ;

  // rule RL_i2c_user_receive_data1
  assign CAN_FIRE_RL_i2c_user_receive_data1 =
	     (i2c_user_mTransFSM == 5'd8 || i2c_user_mTransFSM == 5'd3) &&
	     CAN_FIRE_RL_i2c_user_restore_scl &&
	     i2c_user_eso &&
	     i2c_user_val_SCL &&
	     (i2c_user_dataBit == 4'd0 || i2c_user_dataBit == 4'd8) ;
  assign WILL_FIRE_RL_i2c_user_receive_data1 =
	     CAN_FIRE_RL_i2c_user_receive_data1 &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_toggle_scl
  //   This rule is used to toggle the Serial Clock line based on coSCL input
  assign CAN_FIRE_RL_i2c_user_toggle_scl =
	     i2c_user_st_toggle && CAN_FIRE_RL_i2c_user_restore_scl ;
  assign WILL_FIRE_RL_i2c_user_toggle_scl =
	     CAN_FIRE_RL_i2c_user_toggle_scl &&
	     !WILL_FIRE_RL_i2c_user_wait_interrupt ;

  // rule RL_write_request
  assign CAN_FIRE_RL_write_request =
	     s_xactor_f_wr_addr_EMPTY_N && s_xactor_f_wr_data_EMPTY_N &&
	     s_xactor_f_wr_resp_FULL_N ;
  assign WILL_FIRE_RL_write_request =
	     CAN_FIRE_RL_write_request && !WILL_FIRE_RL_read_request ;

  // rule RL_i2c_user_check_control_reg
  //   Checks the control Reg (after Driver updates it) and based on byte loaded goes to Write/Read
  assign CAN_FIRE_RL_i2c_user_check_control_reg =
	     i2c_user_configchange && i2c_user_eso &&
	     i2c_user_mTransFSM != 5'd6 &&
	     i2c_user_mTransFSM != 5'd1 &&
	     i2c_user_mTransFSM != 5'd12 ;
  assign WILL_FIRE_RL_i2c_user_check_control_reg =
	     CAN_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule __me_check_6
  //   Checks the control Reg (after Driver updates it) and based on byte loaded goes to Write/Read
  assign CAN_FIRE___me_check_6 = 1'b1 ;
  assign WILL_FIRE___me_check_6 = 1'b1 ;

  // rule RL_i2c_user_reset_state
  //   Reset the I2C State Machine and wait for another transaction request
  assign CAN_FIRE_RL_i2c_user_reset_state =
	     i2c_user_mTransFSM == 5'd9 && !i2c_user_ber ;
  assign WILL_FIRE_RL_i2c_user_reset_state =
	     CAN_FIRE_RL_i2c_user_reset_state &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request &&
	     !WILL_FIRE_RL_read_request ;

  // rule RL_i2c_user_wait_interrupt_receive_end
  assign CAN_FIRE_RL_i2c_user_wait_interrupt_receive_end =
	     i2c_user_dataBit == 4'd8 && i2c_user_mTransFSM == 5'd12 &&
	     !i2c_user_val_SCL_in ;
  assign WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end =
	     CAN_FIRE_RL_i2c_user_wait_interrupt_receive_end &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_send_stop_condition
  //   Send a STOP bit signifying no more transaction from this master
  assign CAN_FIRE_RL_i2c_user_send_stop_condition =
	     i2c_user_mTransFSM == 5'd15 && i2c_user_eso &&
	     i2c_user_val_SCL_in ;
  assign WILL_FIRE_RL_i2c_user_send_stop_condition =
	     CAN_FIRE_RL_i2c_user_send_stop_condition &&
	     !WILL_FIRE_RL_i2c_user_check_control_reg &&
	     !WILL_FIRE_RL_write_request ;

  // rule RL_i2c_user_resetfilter
  assign CAN_FIRE_RL_i2c_user_resetfilter = 1'd1 ;
  assign WILL_FIRE_RL_i2c_user_resetfilter =
	     !WILL_FIRE_RL_i2c_user_reset_state &&
	     !WILL_FIRE_RL_i2c_user_idler ;

  // inputs to muxes for submodule ports
  assign MUX_i2c_user_aas_write_1__SEL_1 =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ;
  assign MUX_i2c_user_ack_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ;
  assign MUX_i2c_user_ad0_lrb_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_check_Ack &&
	     (i2c_user_val_SDA_in || i2c_user_val_SCL) ;
  assign MUX_i2c_user_bb_write_1__PSEL_2 =
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans ||
	     WILL_FIRE_RL_i2c_user_send_start_trans ;
  assign MUX_i2c_user_bb_write_1__SEL_2 =
	     MUX_i2c_user_bb_write_1__PSEL_2 && !i2c_user_val_SDA ;
  assign MUX_i2c_user_ber_write_1__SEL_1 =
	     WILL_FIRE_RL_i2c_user_resetfilter && i2c_user_rstsig &&
	     i2c_user_resetcount == 6'd59 ;
  assign MUX_i2c_user_ber_write_1__SEL_3 =
	     WILL_FIRE_RL_i2c_user_check_control_reg && x__h3214 == 2'd1 ;
  assign MUX_i2c_user_ber_write_1__SEL_4 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d303 ;
  assign MUX_i2c_user_ber_write_1__SEL_5 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 == 2'd2 ;
  assign MUX_i2c_user_ber_write_1__SEL_6 =
	     WILL_FIRE_RL_i2c_user_check_Ack && i2c_user_val_SDA_in &&
	     !i2c_user_val_SCL ;
  assign MUX_i2c_user_ber_write_1__SEL_8 =
	     WILL_FIRE_RL_read_request &&
	     s_xactor_f_rd_addr_D_OUT[12:5] == 8'h18 ;
  assign MUX_i2c_user_cOutEn_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ;
  assign MUX_i2c_user_cOutEn_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_check_control_reg &&
	     (x__h3214 != 2'd2 || i2c_user_bb) &&
	     (x__h3214 == 2'd2 || x__h3214 == 2'd1) ;
  assign MUX_i2c_user_configchange_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     i2c_user_mTransFSM != 5'd6 &&
	     i2c_user_mTransFSM != 5'd12 ;
  assign MUX_i2c_user_dOutEn_write_1__PSEL_1 =
	     WILL_FIRE_RL_i2c_user_send_addr ||
	     WILL_FIRE_RL_i2c_user_send_data ;
  assign MUX_i2c_user_dOutEn_write_1__SEL_1 =
	     MUX_i2c_user_dOutEn_write_1__PSEL_1 && i2c_user_dataBit == 4'd0 ;
  assign MUX_i2c_user_dOutEn_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_receive_data1 && i2c_user_dataBit == 4'd0 ;
  assign MUX_i2c_user_dOutEn_write_1__SEL_6 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 != 2'd2 &&
	     NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d128 ;
  assign MUX_i2c_user_dataBit_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300 ;
  assign MUX_i2c_user_dataBit_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 &&
	     i2c_user_last_byte_read ;
  assign MUX_i2c_user_dataBit_write_1__SEL_4 =
	     WILL_FIRE_RL_i2c_user_send_data && i2c_user_dataBit != 4'd0 ;
  assign MUX_i2c_user_dataBit_write_1__SEL_5 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d133 ;
  assign MUX_i2c_user_dataBit_write_1__SEL_7 =
	     WILL_FIRE_RL_i2c_user_send_addr && i2c_user_dataBit != 4'd0 ;
  assign MUX_i2c_user_i2ctime_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h30 ;
  assign MUX_i2c_user_i2ctime_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && !i2c_user_pin &&
	     i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101 ;
  assign MUX_i2c_user_i2ctimeout_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans && !i2c_user_val_SDA ;
  assign MUX_i2c_user_i2ctimeout_write_1__SEL_3 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     (i2c_user_pin || i2c_user_i2ctime[14]) ;
  assign MUX_i2c_user_last_byte_read_write_1__SEL_1 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 != 2'd2 &&
	     NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d139 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_send_stop_condition && i2c_user_val_SDA ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_3 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end &&
	     x__h3214 == 2'd1 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_6 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d274 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_8 =
	     WILL_FIRE_RL_i2c_user_send_data && i2c_user_dataBit == 4'd0 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_9 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_i2c_user_sta_1_CONCAT_i2c_u_ETC___d115 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_11 =
	     WILL_FIRE_RL_i2c_user_send_addr && i2c_user_dataBit == 4'd0 ;
  assign MUX_i2c_user_mTransFSM_write_1__SEL_13 =
	     WILL_FIRE_RL_i2c_user_send_start_trans && !i2c_user_val_SDA ;
  assign MUX_i2c_user_mod_start_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     (s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38) &&
	     !i2c_user_eso ;
  assign MUX_i2c_user_pin_write_1__SEL_2 =
	     WILL_FIRE_RL_write_request &&
	     (s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h10) ;
  assign MUX_i2c_user_pin_write_1__SEL_4 =
	     WILL_FIRE_RL_i2c_user_check_Ack && i2c_user_val_SCL ;
  assign MUX_i2c_user_pin_write_1__SEL_6 =
	     WILL_FIRE_RL_read_request &&
	     s_xactor_f_rd_addr_D_OUT[12:5] == 8'h10 ;
  assign MUX_i2c_user_reSCL_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38 &&
	     !i2c_user_eso ;
  assign MUX_i2c_user_s0_write_1__SEL_1 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h10 ;
  assign MUX_i2c_user_s3_write_1__SEL_2 =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h28 ;
  assign MUX_i2c_user_sendInd_write_1__SEL_1 =
	     MUX_i2c_user_bb_write_1__PSEL_2 && i2c_user_val_SDA ;
  assign MUX_i2c_user_sendInd_write_1__SEL_5 =
	     WILL_FIRE_RL_i2c_user_send_stop_condition && !i2c_user_val_SDA ;
  assign MUX_i2c_user_sendInd_write_1__SEL_6 =
	     WILL_FIRE_RL_i2c_user_send_addr ||
	     WILL_FIRE_RL_i2c_user_reset_state ;
  assign MUX_i2c_user_st_toggle_write_1__SEL_2 =
	     WILL_FIRE_RL_i2c_user_check_control_reg && i2c_user_bb &&
	     x__h3214 == 2'd2 ;
  assign MUX_i2c_user_st_toggle_write_1__SEL_3 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     (i2c_user_pin ||
	      !i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101) ;
  assign MUX_i2c_user_val_SCL_write_1__SEL_1 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && !i2c_user_pin ;
  assign MUX_i2c_user_val_SDA_write_1__SEL_1 =
	     MUX_i2c_user_bb_write_1__PSEL_2 && i2c_user_val_SDA ;
  assign MUX_i2c_user_val_SDA_write_1__SEL_6 =
	     MUX_i2c_user_dOutEn_write_1__PSEL_1 && i2c_user_dataBit != 4'd0 ;
  assign MUX_i2c_user_val_SDA_write_1__SEL_7 =
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d125 ;
  assign MUX_i2c_user_ack_write_1__VAL_1 =
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12) &&
	     !i2c_user_bb ||
	     s_xactor_f_wr_data_D_OUT[4] ;
  assign MUX_i2c_user_ad0_lrb_write_1__VAL_2 =
	     i2c_user_val_SDA_in && !i2c_user_val_SCL ;
  assign MUX_i2c_user_coSCL_write_1__VAL_3 = i2c_user_coSCL - 32'd1 ;
  assign MUX_i2c_user_dOutEn_write_1__VAL_6 =
	     i2c_user_s3 == 8'h0A || !i2c_user_operation ;
  assign MUX_i2c_user_eso_write_1__VAL_1 =
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12) &&
	     !i2c_user_bb ||
	     s_xactor_f_wr_data_D_OUT[10] ;
  assign MUX_i2c_user_i2ctime_write_1__VAL_2 =
	     { 1'd1, i2c_user_i2ctime[14:0] } ;
  assign MUX_i2c_user_i2ctimeout_write_1__VAL_3 =
	     i2c_user_pin ? 14'd1 : x__h5910 ;
  assign MUX_i2c_user_mTransFSM_write_1__VAL_5 =
	     (x__h3214 == 2'd2) ? 5'd2 : 5'd15 ;
  assign MUX_i2c_user_mTransFSM_write_1__VAL_6 =
	     (s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08) ?
	       IF_s_xactor_f_wr_data_first__56_BITS_6_TO_5_57_ETC___d278 :
	       5'd1 ;
  assign MUX_i2c_user_mTransFSM_write_1__VAL_7 =
	     (i2c_user_dataBit == 4'd0) ?
	       (i2c_user_last_byte_read ? 5'd3 : 5'd11) :
	       5'd12 ;
  assign MUX_i2c_user_mTransFSM_write_1__VAL_9 =
	     i2c_user_pin ?
	       CASE_x214_1_15_2_9_IF_i2c_user_s3_EQ_0xA_THEN__ETC__q1 :
	       5'd15 ;
  assign MUX_i2c_user_mTransFSM_write_1__VAL_10 =
	     (i2c_user_val_SDA_in && !i2c_user_val_SCL) ? 5'd12 : 5'd6 ;
  assign MUX_i2c_user_pin_write_1__VAL_2 =
	     s_xactor_f_wr_addr_D_OUT[12:5] != 8'h08 ||
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12) &&
	     !i2c_user_bb ||
	     s_xactor_f_wr_data_D_OUT[11] ;
  assign MUX_i2c_user_resetcount_write_1__VAL_2 =
	     i2c_user_rstsig ? x__h6890 : 6'd0 ;
  assign MUX_i2c_user_s0_write_1__VAL_2 =
	     i2c_user_val_SDA_in ?
	       i2c_user_s0 | x__h6819 :
	       i2c_user_s0 & y__h6860 ;
  assign MUX_i2c_user_s3_write_1__VAL_5 =
	     (i2c_user_val_SDA_in && !i2c_user_val_SCL) ? 8'h05 : 8'h06 ;
  assign MUX_i2c_user_sendInd_write_1__VAL_1 = i2c_user_sendInd - 2'd1 ;
  assign MUX_i2c_user_val_SDA_write_1__VAL_1 = _0b110__q2[i2c_user_sendInd] ;
  assign MUX_i2c_user_val_SDA_write_1__VAL_5 = _0b1__q3[i2c_user_sendInd] ;
  assign MUX_i2c_user_val_SDA_write_1__VAL_7 = x__h3214 != 2'd1 && x__h6744 ;

  // register i2c_user_aas
  assign i2c_user_aas_D_IN = 1'd0 ;
  assign i2c_user_aas_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_ack
  assign i2c_user_ack_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 &&
	     MUX_i2c_user_ack_write_1__VAL_1 ;
  assign i2c_user_ack_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_ad0_lrb
  assign i2c_user_ad0_lrb_D_IN =
	     MUX_i2c_user_ad0_lrb_write_1__SEL_2 &&
	     MUX_i2c_user_ad0_lrb_write_1__VAL_2 ;
  assign i2c_user_ad0_lrb_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_check_Ack &&
	     (i2c_user_val_SDA_in || i2c_user_val_SCL) ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_bb
  assign i2c_user_bb_D_IN = !MUX_i2c_user_bb_write_1__SEL_2 ;
  assign i2c_user_bb_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     (WILL_FIRE_RL_i2c_user_send_rtstart_trans ||
	      WILL_FIRE_RL_i2c_user_send_start_trans) &&
	     !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_ber
  always@(MUX_i2c_user_ber_write_1__SEL_1 or
	  WILL_FIRE_RL_i2c_user_reset_state or
	  MUX_i2c_user_ber_write_1__SEL_3 or
	  MUX_i2c_user_ber_write_1__SEL_4 or
	  MUX_i2c_user_ber_write_1__SEL_5 or
	  MUX_i2c_user_ber_write_1__SEL_6 or
	  MUX_i2c_user_aas_write_1__SEL_1 or MUX_i2c_user_ber_write_1__SEL_8)
  case (1'b1)
    MUX_i2c_user_ber_write_1__SEL_1 || WILL_FIRE_RL_i2c_user_reset_state:
	i2c_user_ber_D_IN = 1'd0;
    MUX_i2c_user_ber_write_1__SEL_3 || MUX_i2c_user_ber_write_1__SEL_4 ||
    MUX_i2c_user_ber_write_1__SEL_5 ||
    MUX_i2c_user_ber_write_1__SEL_6:
	i2c_user_ber_D_IN = 1'd1;
    MUX_i2c_user_aas_write_1__SEL_1 || MUX_i2c_user_ber_write_1__SEL_8:
	i2c_user_ber_D_IN = 1'd0;
    default: i2c_user_ber_D_IN = 1'bx /* unspecified value */ ;
  endcase
  assign i2c_user_ber_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_check_control_reg && x__h3214 == 2'd1 ||
	     WILL_FIRE_RL_i2c_user_check_Ack && i2c_user_val_SDA_in &&
	     !i2c_user_val_SCL ||
	     WILL_FIRE_RL_read_request &&
	     s_xactor_f_rd_addr_D_OUT[12:5] == 8'h18 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 == 2'd2 ||
	     WILL_FIRE_RL_i2c_user_resetfilter && i2c_user_rstsig &&
	     i2c_user_resetcount == 6'd59 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d303 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_cOutEn
  assign i2c_user_cOutEn_D_IN = !WILL_FIRE_RL_i2c_user_reset_state ;
  assign i2c_user_cOutEn_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ||
	     WILL_FIRE_RL_i2c_user_check_control_reg &&
	     (x__h3214 != 2'd2 || i2c_user_bb) &&
	     (x__h3214 == 2'd2 || x__h3214 == 2'd1) ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_c_scl
  assign i2c_user_c_scl_D_IN = s_xactor_f_wr_data_D_OUT[35:4] ;
  assign i2c_user_c_scl_EN = MUX_i2c_user_reSCL_write_1__SEL_1 ;

  // register i2c_user_coSCL
  always@(WILL_FIRE_RL_i2c_user_set_scl_clock or
	  i2c_user_c_scl or
	  WILL_FIRE_RL_i2c_user_restore_scl or
	  i2c_user_reSCL or
	  WILL_FIRE_RL_i2c_user_count_scl or
	  MUX_i2c_user_coSCL_write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_i2c_user_set_scl_clock:
	  i2c_user_coSCL_D_IN = i2c_user_c_scl;
      WILL_FIRE_RL_i2c_user_restore_scl: i2c_user_coSCL_D_IN = i2c_user_reSCL;
      WILL_FIRE_RL_i2c_user_count_scl:
	  i2c_user_coSCL_D_IN = MUX_i2c_user_coSCL_write_1__VAL_3;
      default: i2c_user_coSCL_D_IN =
		   32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign i2c_user_coSCL_EN =
	     WILL_FIRE_RL_i2c_user_set_scl_clock ||
	     WILL_FIRE_RL_i2c_user_restore_scl ||
	     WILL_FIRE_RL_i2c_user_count_scl ;

  // register i2c_user_configchange
  assign i2c_user_configchange_D_IN =
	     MUX_i2c_user_configchange_write_1__SEL_1 ;
  assign i2c_user_configchange_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     i2c_user_mTransFSM != 5'd6 &&
	     i2c_user_mTransFSM != 5'd12 ||
	     WILL_FIRE_RL_i2c_user_check_control_reg ;

  // register i2c_user_cprescaler
  assign i2c_user_cprescaler_D_IN = 8'h0 ;
  assign i2c_user_cprescaler_EN = 1'b0 ;

  // register i2c_user_cycwaste
  always@(i2c_user_cycwaste or x__h2667)
  begin
    case (i2c_user_cycwaste)
      10'd0: i2c_user_cycwaste_D_IN = x__h2667;
      10'd600: i2c_user_cycwaste_D_IN = 10'd0;
      default: i2c_user_cycwaste_D_IN = x__h2667;
    endcase
  end
  assign i2c_user_cycwaste_EN = WILL_FIRE_RL_i2c_user_idler ;

  // register i2c_user_dOutEn
  always@(MUX_i2c_user_dOutEn_write_1__SEL_6 or
	  MUX_i2c_user_dOutEn_write_1__VAL_6 or
	  MUX_i2c_user_dOutEn_write_1__SEL_1 or
	  WILL_FIRE_RL_i2c_user_reset_state or
	  MUX_i2c_user_dOutEn_write_1__SEL_2 or
	  MUX_i2c_user_cOutEn_write_1__SEL_1 or
	  MUX_i2c_user_cOutEn_write_1__SEL_2 or
	  MUX_i2c_user_ad0_lrb_write_1__SEL_2)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_i2c_user_dOutEn_write_1__SEL_6:
	  i2c_user_dOutEn_D_IN = MUX_i2c_user_dOutEn_write_1__VAL_6;
      MUX_i2c_user_dOutEn_write_1__SEL_1 || WILL_FIRE_RL_i2c_user_reset_state:
	  i2c_user_dOutEn_D_IN = 1'd0;
      MUX_i2c_user_dOutEn_write_1__SEL_2 ||
      MUX_i2c_user_cOutEn_write_1__SEL_1 ||
      MUX_i2c_user_cOutEn_write_1__SEL_2 ||
      MUX_i2c_user_ad0_lrb_write_1__SEL_2:
	  i2c_user_dOutEn_D_IN = 1'd1;
      default: i2c_user_dOutEn_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign i2c_user_dOutEn_EN =
	     (WILL_FIRE_RL_i2c_user_send_addr ||
	      WILL_FIRE_RL_i2c_user_send_data) &&
	     i2c_user_dataBit == 4'd0 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ||
	     WILL_FIRE_RL_i2c_user_check_control_reg &&
	     (x__h3214 != 2'd2 || i2c_user_bb) &&
	     (x__h3214 == 2'd2 || x__h3214 == 2'd1) ||
	     WILL_FIRE_RL_i2c_user_check_Ack &&
	     (i2c_user_val_SDA_in || i2c_user_val_SCL) ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 != 2'd2 &&
	     NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d128 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_dataBit
  always@(MUX_i2c_user_dataBit_write_1__SEL_1 or
	  MUX_i2c_user_dataBit_write_1__SEL_2 or
	  WILL_FIRE_RL_i2c_user_receive_data or
	  x__h6839 or
	  MUX_i2c_user_dataBit_write_1__SEL_4 or
	  MUX_i2c_user_dataBit_write_1__SEL_5 or
	  WILL_FIRE_RL_i2c_user_check_Ack or
	  MUX_i2c_user_dataBit_write_1__SEL_7)
  case (1'b1)
    MUX_i2c_user_dataBit_write_1__SEL_1 ||
    MUX_i2c_user_dataBit_write_1__SEL_2:
	i2c_user_dataBit_D_IN = 4'd8;
    WILL_FIRE_RL_i2c_user_receive_data: i2c_user_dataBit_D_IN = x__h6839;
    MUX_i2c_user_dataBit_write_1__SEL_4: i2c_user_dataBit_D_IN = x__h6839;
    MUX_i2c_user_dataBit_write_1__SEL_5: i2c_user_dataBit_D_IN = x__h6839;
    WILL_FIRE_RL_i2c_user_check_Ack: i2c_user_dataBit_D_IN = 4'd8;
    MUX_i2c_user_dataBit_write_1__SEL_7: i2c_user_dataBit_D_IN = x__h6839;
    default: i2c_user_dataBit_D_IN = 4'bxxxx /* unspecified value */ ;
  endcase
  assign i2c_user_dataBit_EN =
	     (WILL_FIRE_RL_i2c_user_send_addr ||
	      WILL_FIRE_RL_i2c_user_send_data) &&
	     i2c_user_dataBit != 4'd0 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d133 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 &&
	     i2c_user_last_byte_read ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300 ||
	     WILL_FIRE_RL_i2c_user_receive_data ||
	     WILL_FIRE_RL_i2c_user_check_Ack ;

  // register i2c_user_drv0_rg
  assign i2c_user_drv0_rg_D_IN = 8'h0 ;
  assign i2c_user_drv0_rg_EN = 1'b0 ;

  // register i2c_user_drv1_rg
  assign i2c_user_drv1_rg_D_IN = 8'h0 ;
  assign i2c_user_drv1_rg_EN = 1'b0 ;

  // register i2c_user_drv2_rg
  assign i2c_user_drv2_rg_D_IN = 8'h0 ;
  assign i2c_user_drv2_rg_EN = 1'b0 ;

  // register i2c_user_eni
  assign i2c_user_eni_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 && s_xactor_f_wr_data_D_OUT[7] ;
  assign i2c_user_eni_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_es1
  assign i2c_user_es1_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 && s_xactor_f_wr_data_D_OUT[9] ;
  assign i2c_user_es1_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_es2
  assign i2c_user_es2_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 && s_xactor_f_wr_data_D_OUT[8] ;
  assign i2c_user_es2_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_eso
  assign i2c_user_eso_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 &&
	     MUX_i2c_user_eso_write_1__VAL_1 ;
  assign i2c_user_eso_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_i2ctime
  assign i2c_user_i2ctime_D_IN =
	     MUX_i2c_user_i2ctime_write_1__SEL_1 ?
	       s_xactor_f_wr_data_D_OUT[19:4] :
	       MUX_i2c_user_i2ctime_write_1__VAL_2 ;
  assign i2c_user_i2ctime_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h30 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt && !i2c_user_pin &&
	     i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101 ;

  // register i2c_user_i2ctimeout
  assign i2c_user_i2ctimeout_D_IN =
	     MUX_i2c_user_i2ctimeout_write_1__SEL_3 ?
	       MUX_i2c_user_i2ctimeout_write_1__VAL_3 :
	       14'd1 ;
  assign i2c_user_i2ctimeout_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     (i2c_user_pin || i2c_user_i2ctime[14]) ||
	     WILL_FIRE_RL_i2c_user_check_Ack ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_lab
  assign i2c_user_lab_D_IN = 1'd0 ;
  assign i2c_user_lab_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_last_byte_read
  assign i2c_user_last_byte_read_D_IN =
	     MUX_i2c_user_last_byte_read_write_1__SEL_1 ;
  assign i2c_user_last_byte_read_EN =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && i2c_user_pin &&
	     x__h3214 != 2'd2 &&
	     NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d139 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 &&
	     i2c_user_last_byte_read ;

  // register i2c_user_mTransFSM
  always@(MUX_i2c_user_ber_write_1__SEL_1 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_2 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_3 or
	  WILL_FIRE_RL_i2c_user_reset_state or
	  MUX_i2c_user_cOutEn_write_1__SEL_2 or
	  MUX_i2c_user_mTransFSM_write_1__VAL_5 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_6 or
	  MUX_i2c_user_mTransFSM_write_1__VAL_6 or
	  WILL_FIRE_RL_i2c_user_receive_data1 or
	  MUX_i2c_user_mTransFSM_write_1__VAL_7 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_8 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_9 or
	  MUX_i2c_user_mTransFSM_write_1__VAL_9 or
	  MUX_i2c_user_ad0_lrb_write_1__SEL_2 or
	  MUX_i2c_user_mTransFSM_write_1__VAL_10 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_11 or
	  MUX_i2c_user_i2ctimeout_write_1__SEL_2 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_13 or
	  MUX_i2c_user_aas_write_1__SEL_1)
  case (1'b1)
    MUX_i2c_user_ber_write_1__SEL_1: i2c_user_mTransFSM_D_IN = 5'd9;
    MUX_i2c_user_mTransFSM_write_1__SEL_2: i2c_user_mTransFSM_D_IN = 5'd1;
    MUX_i2c_user_mTransFSM_write_1__SEL_3: i2c_user_mTransFSM_D_IN = 5'd15;
    WILL_FIRE_RL_i2c_user_reset_state: i2c_user_mTransFSM_D_IN = 5'd1;
    MUX_i2c_user_cOutEn_write_1__SEL_2:
	i2c_user_mTransFSM_D_IN = MUX_i2c_user_mTransFSM_write_1__VAL_5;
    MUX_i2c_user_mTransFSM_write_1__SEL_6:
	i2c_user_mTransFSM_D_IN = MUX_i2c_user_mTransFSM_write_1__VAL_6;
    WILL_FIRE_RL_i2c_user_receive_data1:
	i2c_user_mTransFSM_D_IN = MUX_i2c_user_mTransFSM_write_1__VAL_7;
    MUX_i2c_user_mTransFSM_write_1__SEL_8: i2c_user_mTransFSM_D_IN = 5'd11;
    MUX_i2c_user_mTransFSM_write_1__SEL_9:
	i2c_user_mTransFSM_D_IN = MUX_i2c_user_mTransFSM_write_1__VAL_9;
    MUX_i2c_user_ad0_lrb_write_1__SEL_2:
	i2c_user_mTransFSM_D_IN = MUX_i2c_user_mTransFSM_write_1__VAL_10;
    MUX_i2c_user_mTransFSM_write_1__SEL_11: i2c_user_mTransFSM_D_IN = 5'd11;
    MUX_i2c_user_i2ctimeout_write_1__SEL_2: i2c_user_mTransFSM_D_IN = 5'd6;
    MUX_i2c_user_mTransFSM_write_1__SEL_13: i2c_user_mTransFSM_D_IN = 5'd5;
    MUX_i2c_user_aas_write_1__SEL_1: i2c_user_mTransFSM_D_IN = 5'd16;
    default: i2c_user_mTransFSM_D_IN = 5'bxxxxx /* unspecified value */ ;
  endcase
  assign i2c_user_mTransFSM_EN =
	     WILL_FIRE_RL_i2c_user_send_stop_condition && i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end &&
	     x__h3214 == 2'd1 ||
	     (WILL_FIRE_RL_i2c_user_send_addr ||
	      WILL_FIRE_RL_i2c_user_send_data) &&
	     i2c_user_dataBit == 4'd0 ||
	     WILL_FIRE_RL_i2c_user_check_control_reg &&
	     (x__h3214 != 2'd2 || i2c_user_bb) &&
	     (x__h3214 == 2'd2 || x__h3214 == 2'd1) ||
	     WILL_FIRE_RL_i2c_user_send_start_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_check_Ack &&
	     (i2c_user_val_SDA_in || i2c_user_val_SCL) ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_i2c_user_sta_1_CONCAT_i2c_u_ETC___d115 ||
	     WILL_FIRE_RL_i2c_user_resetfilter && i2c_user_rstsig &&
	     i2c_user_resetcount == 6'd59 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d274 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_mod_start
  assign i2c_user_mod_start_D_IN = MUX_i2c_user_mod_start_write_1__SEL_1 ;
  assign i2c_user_mod_start_EN =
	     WILL_FIRE_RL_write_request &&
	     (s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38) &&
	     !i2c_user_eso ||
	     WILL_FIRE_RL_i2c_user_set_i2c_clock ;

  // register i2c_user_operation
  assign i2c_user_operation_D_IN = i2c_user_s0[0] ;
  assign i2c_user_operation_EN = MUX_i2c_user_mTransFSM_write_1__SEL_11 ;

  // register i2c_user_pd_rg
  assign i2c_user_pd_rg_D_IN = 8'h0 ;
  assign i2c_user_pd_rg_EN = 1'b0 ;

  // register i2c_user_pin
  always@(WILL_FIRE_RL_i2c_user_reset_state or
	  MUX_i2c_user_pin_write_1__SEL_2 or
	  MUX_i2c_user_pin_write_1__VAL_2 or
	  MUX_i2c_user_dataBit_write_1__SEL_2 or
	  MUX_i2c_user_pin_write_1__SEL_4 or
	  MUX_i2c_user_i2ctimeout_write_1__SEL_2 or
	  MUX_i2c_user_pin_write_1__SEL_6)
  case (1'b1)
    WILL_FIRE_RL_i2c_user_reset_state: i2c_user_pin_D_IN = 1'd1;
    MUX_i2c_user_pin_write_1__SEL_2:
	i2c_user_pin_D_IN = MUX_i2c_user_pin_write_1__VAL_2;
    MUX_i2c_user_dataBit_write_1__SEL_2 || MUX_i2c_user_pin_write_1__SEL_4 ||
    MUX_i2c_user_i2ctimeout_write_1__SEL_2:
	i2c_user_pin_D_IN = 1'd0;
    MUX_i2c_user_pin_write_1__SEL_6: i2c_user_pin_D_IN = 1'd1;
    default: i2c_user_pin_D_IN = 1'bx /* unspecified value */ ;
  endcase
  assign i2c_user_pin_EN =
	     WILL_FIRE_RL_i2c_user_check_Ack && i2c_user_val_SCL ||
	     WILL_FIRE_RL_read_request &&
	     s_xactor_f_rd_addr_D_OUT[12:5] == 8'h10 ||
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 &&
	     i2c_user_last_byte_read ||
	     WILL_FIRE_RL_write_request &&
	     (s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h10) ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_ppen_rg
  assign i2c_user_ppen_rg_D_IN = 8'h0 ;
  assign i2c_user_ppen_rg_EN = 1'b0 ;

  // register i2c_user_prg_slew_rg
  assign i2c_user_prg_slew_rg_D_IN = 8'h0 ;
  assign i2c_user_prg_slew_rg_EN = 1'b0 ;

  // register i2c_user_puq_rg
  assign i2c_user_puq_rg_D_IN = 8'h0 ;
  assign i2c_user_puq_rg_EN = 1'b0 ;

  // register i2c_user_pwrup_pull_en_rg
  assign i2c_user_pwrup_pull_en_rg_D_IN = 8'h0 ;
  assign i2c_user_pwrup_pull_en_rg_EN = 1'b0 ;

  // register i2c_user_pwrupzhl_rg
  assign i2c_user_pwrupzhl_rg_D_IN = 8'h0 ;
  assign i2c_user_pwrupzhl_rg_EN = 1'b0 ;

  // register i2c_user_reSCL
  assign i2c_user_reSCL_D_IN =
	     MUX_i2c_user_reSCL_write_1__SEL_1 ? 32'd0 : i2c_user_c_scl ;
  assign i2c_user_reSCL_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38 &&
	     !i2c_user_eso ||
	     WILL_FIRE_RL_i2c_user_set_scl_clock ;

  // register i2c_user_resetcount
  assign i2c_user_resetcount_D_IN =
	     WILL_FIRE_RL_i2c_user_resetfilter ?
	       MUX_i2c_user_resetcount_write_1__VAL_2 :
	       6'd0 ;
  assign i2c_user_resetcount_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_resetfilter ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_rprescaler
  assign i2c_user_rprescaler_D_IN = 8'd0 ;
  assign i2c_user_rprescaler_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 &&
	     !i2c_user_eso ;

  // register i2c_user_rstsig
  assign i2c_user_rstsig_D_IN = 1'b0 ;
  assign i2c_user_rstsig_EN = 1'b0 ;

  // register i2c_user_s0
  assign i2c_user_s0_D_IN =
	     MUX_i2c_user_s0_write_1__SEL_1 ?
	       s_xactor_f_wr_data_D_OUT[11:4] :
	       MUX_i2c_user_s0_write_1__VAL_2 ;
  assign i2c_user_s0_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h10 ||
	     WILL_FIRE_RL_i2c_user_receive_data ;

  // register i2c_user_s01
  assign i2c_user_s01_D_IN = s_xactor_f_wr_data_D_OUT[11:4] ;
  assign i2c_user_s01_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h20 ;

  // register i2c_user_s2
  assign i2c_user_s2_D_IN = s_xactor_f_wr_data_D_OUT[11:4] ;
  assign i2c_user_s2_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 &&
	     !i2c_user_eso ;

  // register i2c_user_s3
  always@(MUX_i2c_user_ber_write_1__SEL_1 or
	  MUX_i2c_user_s3_write_1__SEL_2 or
	  s_xactor_f_wr_data_D_OUT or
	  MUX_i2c_user_dataBit_write_1__SEL_2 or
	  MUX_i2c_user_i2ctime_write_1__SEL_2 or
	  MUX_i2c_user_ad0_lrb_write_1__SEL_2 or
	  MUX_i2c_user_s3_write_1__VAL_5 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_11 or
	  MUX_i2c_user_i2ctimeout_write_1__SEL_2 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_13 or
	  MUX_i2c_user_aas_write_1__SEL_1)
  case (1'b1)
    MUX_i2c_user_ber_write_1__SEL_1: i2c_user_s3_D_IN = 8'h07;
    MUX_i2c_user_s3_write_1__SEL_2:
	i2c_user_s3_D_IN = s_xactor_f_wr_data_D_OUT[11:4];
    MUX_i2c_user_dataBit_write_1__SEL_2: i2c_user_s3_D_IN = 8'h08;
    MUX_i2c_user_i2ctime_write_1__SEL_2: i2c_user_s3_D_IN = 8'h0C;
    MUX_i2c_user_ad0_lrb_write_1__SEL_2:
	i2c_user_s3_D_IN = MUX_i2c_user_s3_write_1__VAL_5;
    MUX_i2c_user_mTransFSM_write_1__SEL_11: i2c_user_s3_D_IN = 8'b00000001;
    MUX_i2c_user_i2ctimeout_write_1__SEL_2: i2c_user_s3_D_IN = 8'h0A;
    MUX_i2c_user_mTransFSM_write_1__SEL_13: i2c_user_s3_D_IN = 8'h0B;
    MUX_i2c_user_aas_write_1__SEL_1: i2c_user_s3_D_IN = 8'h09;
    default: i2c_user_s3_D_IN = 8'bxxxxxxxx /* unspecified value */ ;
  endcase
  assign i2c_user_s3_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_send_addr && i2c_user_dataBit == 4'd0 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h28 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt && !i2c_user_pin &&
	     i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101 ||
	     WILL_FIRE_RL_i2c_user_send_rtstart_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_send_start_trans && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_check_Ack &&
	     (i2c_user_val_SDA_in || i2c_user_val_SCL) ||
	     WILL_FIRE_RL_i2c_user_resetfilter && i2c_user_rstsig &&
	     i2c_user_resetcount == 6'd59 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 &&
	     i2c_user_last_byte_read ;

  // register i2c_user_scl_start
  assign i2c_user_scl_start_D_IN = MUX_i2c_user_mod_start_write_1__SEL_1 ;
  assign i2c_user_scl_start_EN =
	     WILL_FIRE_RL_write_request &&
	     (s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38) &&
	     !i2c_user_eso ||
	     WILL_FIRE_RL_i2c_user_set_scl_clock ;

  // register i2c_user_sendInd
  always@(MUX_i2c_user_sendInd_write_1__SEL_1 or
	  MUX_i2c_user_sendInd_write_1__VAL_1 or
	  MUX_i2c_user_sendInd_write_1__SEL_5 or
	  MUX_i2c_user_aas_write_1__SEL_1 or
	  MUX_i2c_user_ber_write_1__SEL_3 or
	  MUX_i2c_user_cOutEn_write_1__SEL_1 or
	  MUX_i2c_user_sendInd_write_1__SEL_6)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_i2c_user_sendInd_write_1__SEL_1:
	  i2c_user_sendInd_D_IN = MUX_i2c_user_sendInd_write_1__VAL_1;
      MUX_i2c_user_sendInd_write_1__SEL_5:
	  i2c_user_sendInd_D_IN = MUX_i2c_user_sendInd_write_1__VAL_1;
      MUX_i2c_user_aas_write_1__SEL_1 || MUX_i2c_user_ber_write_1__SEL_3 ||
      MUX_i2c_user_cOutEn_write_1__SEL_1 ||
      MUX_i2c_user_sendInd_write_1__SEL_6:
	  i2c_user_sendInd_D_IN = 2'd2;
      default: i2c_user_sendInd_D_IN = 2'bxx /* unspecified value */ ;
    endcase
  end
  assign i2c_user_sendInd_EN =
	     (WILL_FIRE_RL_i2c_user_send_rtstart_trans ||
	      WILL_FIRE_RL_i2c_user_send_start_trans) &&
	     i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_check_control_reg && x__h3214 == 2'd1 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ||
	     WILL_FIRE_RL_i2c_user_send_stop_condition && !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_send_addr ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_st_toggle
  always@(MUX_i2c_user_st_toggle_write_1__SEL_3 or
	  i2c_user_pin or
	  WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end or
	  x__h3214 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_2 or
	  WILL_FIRE_RL_i2c_user_reset_state or
	  MUX_i2c_user_st_toggle_write_1__SEL_2 or
	  MUX_i2c_user_dataBit_write_1__SEL_1)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_i2c_user_st_toggle_write_1__SEL_3:
	  i2c_user_st_toggle_D_IN = i2c_user_pin;
      WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end:
	  i2c_user_st_toggle_D_IN = x__h3214 == 2'd1;
      MUX_i2c_user_mTransFSM_write_1__SEL_2 ||
      WILL_FIRE_RL_i2c_user_reset_state:
	  i2c_user_st_toggle_D_IN = 1'd0;
      MUX_i2c_user_st_toggle_write_1__SEL_2 ||
      MUX_i2c_user_dataBit_write_1__SEL_1:
	  i2c_user_st_toggle_D_IN = 1'd1;
      default: i2c_user_st_toggle_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign i2c_user_st_toggle_EN =
	     WILL_FIRE_RL_i2c_user_send_stop_condition && i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_check_control_reg && i2c_user_bb &&
	     x__h3214 == 2'd2 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     (i2c_user_pin ||
	      !i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101) ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_sta
  assign i2c_user_sta_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 && s_xactor_f_wr_data_D_OUT[6] ;
  assign i2c_user_sta_EN =
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     (WILL_FIRE_RL_i2c_user_send_rtstart_trans ||
	      WILL_FIRE_RL_i2c_user_send_start_trans) &&
	     !i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_sto
  assign i2c_user_sto_D_IN =
	     MUX_i2c_user_ack_write_1__SEL_1 && s_xactor_f_wr_data_D_OUT[5] ;
  assign i2c_user_sto_EN =
	     WILL_FIRE_RL_i2c_user_send_stop_condition && i2c_user_val_SDA ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_sts
  assign i2c_user_sts_D_IN = 1'd0 ;
  assign i2c_user_sts_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // register i2c_user_val_SCL
  assign i2c_user_val_SCL_D_IN =
	     !MUX_i2c_user_val_SCL_write_1__SEL_1 && ~i2c_user_val_SCL ;
  assign i2c_user_val_SCL_EN =
	     WILL_FIRE_RL_i2c_user_wait_interrupt && !i2c_user_pin ||
	     WILL_FIRE_RL_i2c_user_toggle_scl ;

  // register i2c_user_val_SCL_in
  assign i2c_user_val_SCL_in_D_IN = io_scl_in_in ;
  assign i2c_user_val_SCL_in_EN = 1'd1 ;

  // register i2c_user_val_SDA
  always@(MUX_i2c_user_dOutEn_write_1__SEL_2 or
	  i2c_user_last_byte_read or
	  MUX_i2c_user_val_SDA_write_1__SEL_1 or
	  MUX_i2c_user_val_SDA_write_1__VAL_1 or
	  MUX_i2c_user_sendInd_write_1__SEL_5 or
	  MUX_i2c_user_val_SDA_write_1__VAL_5 or
	  MUX_i2c_user_val_SDA_write_1__SEL_6 or
	  x__h6744 or
	  MUX_i2c_user_val_SDA_write_1__SEL_7 or
	  MUX_i2c_user_val_SDA_write_1__VAL_7 or
	  MUX_i2c_user_mTransFSM_write_1__SEL_3 or
	  MUX_i2c_user_st_toggle_write_1__SEL_2 or
	  MUX_i2c_user_dataBit_write_1__SEL_1)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_i2c_user_dOutEn_write_1__SEL_2:
	  i2c_user_val_SDA_D_IN = i2c_user_last_byte_read;
      MUX_i2c_user_val_SDA_write_1__SEL_1:
	  i2c_user_val_SDA_D_IN = MUX_i2c_user_val_SDA_write_1__VAL_1;
      MUX_i2c_user_sendInd_write_1__SEL_5:
	  i2c_user_val_SDA_D_IN = MUX_i2c_user_val_SDA_write_1__VAL_5;
      MUX_i2c_user_val_SDA_write_1__SEL_6: i2c_user_val_SDA_D_IN = x__h6744;
      MUX_i2c_user_val_SDA_write_1__SEL_7:
	  i2c_user_val_SDA_D_IN = MUX_i2c_user_val_SDA_write_1__VAL_7;
      MUX_i2c_user_mTransFSM_write_1__SEL_3: i2c_user_val_SDA_D_IN = 1'd0;
      MUX_i2c_user_st_toggle_write_1__SEL_2 ||
      MUX_i2c_user_dataBit_write_1__SEL_1:
	  i2c_user_val_SDA_D_IN = 1'd1;
      default: i2c_user_val_SDA_D_IN = 1'bx /* unspecified value */ ;
    endcase
  end
  assign i2c_user_val_SDA_EN =
	     (WILL_FIRE_RL_i2c_user_send_rtstart_trans ||
	      WILL_FIRE_RL_i2c_user_send_start_trans) &&
	     i2c_user_val_SDA ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt_receive_end &&
	     x__h3214 == 2'd1 ||
	     WILL_FIRE_RL_i2c_user_receive_data1 &&
	     i2c_user_dataBit == 4'd0 ||
	     WILL_FIRE_RL_i2c_user_check_control_reg && i2c_user_bb &&
	     x__h3214 == 2'd2 ||
	     WILL_FIRE_RL_i2c_user_send_stop_condition && !i2c_user_val_SDA ||
	     (WILL_FIRE_RL_i2c_user_send_addr ||
	      WILL_FIRE_RL_i2c_user_send_data) &&
	     i2c_user_dataBit != 4'd0 ||
	     WILL_FIRE_RL_i2c_user_wait_interrupt &&
	     i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d125 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300 ;

  // register i2c_user_val_SDA_in
  assign i2c_user_val_SDA_in_D_IN = io_sda_in_in ;
  assign i2c_user_val_SDA_in_EN = 1'd1 ;

  // register i2c_user_zero
  assign i2c_user_zero_D_IN = 1'd0 ;
  assign i2c_user_zero_EN =
	     WILL_FIRE_RL_i2c_user_idler && i2c_user_cycwaste == 10'd600 ||
	     WILL_FIRE_RL_write_request &&
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 ||
	     WILL_FIRE_RL_i2c_user_reset_state ;

  // submodule s_xactor_f_rd_addr
  assign s_xactor_f_rd_addr_D_IN =
	     { slave_m_arvalid_araddr,
	       slave_m_arvalid_arprot,
	       slave_m_arvalid_arsize } ;
  assign s_xactor_f_rd_addr_ENQ =
	     slave_m_arvalid_arvalid && s_xactor_f_rd_addr_FULL_N ;
  assign s_xactor_f_rd_addr_DEQ =
	     s_xactor_f_rd_addr_EMPTY_N && s_xactor_f_rd_data_FULL_N ;
  assign s_xactor_f_rd_addr_CLR = 1'b0 ;

  // submodule s_xactor_f_rd_data
  assign s_xactor_f_rd_data_D_IN =
	     { (s_xactor_f_rd_addr_D_OUT[12:5] != 8'h08 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h18 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h20 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h10 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h0 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h28 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h30 &&
		s_xactor_f_rd_addr_D_OUT[12:5] != 8'h38) ?
		 2'd2 :
		 2'd0,
	       IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 } ;
  assign s_xactor_f_rd_data_ENQ =
	     s_xactor_f_rd_addr_EMPTY_N && s_xactor_f_rd_data_FULL_N ;
  assign s_xactor_f_rd_data_DEQ =
	     slave_m_rready_rready && s_xactor_f_rd_data_EMPTY_N ;
  assign s_xactor_f_rd_data_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_addr
  assign s_xactor_f_wr_addr_D_IN =
	     { slave_m_awvalid_awaddr,
	       slave_m_awvalid_awprot,
	       slave_m_awvalid_awsize } ;
  assign s_xactor_f_wr_addr_ENQ =
	     slave_m_awvalid_awvalid && s_xactor_f_wr_addr_FULL_N ;
  assign s_xactor_f_wr_addr_DEQ =
	     CAN_FIRE_RL_write_request && !WILL_FIRE_RL_read_request ;
  assign s_xactor_f_wr_addr_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_data
  assign s_xactor_f_wr_data_D_IN =
	     { slave_m_wvalid_wdata, slave_m_wvalid_wstrb } ;
  assign s_xactor_f_wr_data_ENQ =
	     slave_m_wvalid_wvalid && s_xactor_f_wr_data_FULL_N ;
  assign s_xactor_f_wr_data_DEQ =
	     CAN_FIRE_RL_write_request && !WILL_FIRE_RL_read_request ;
  assign s_xactor_f_wr_data_CLR = 1'b0 ;

  // submodule s_xactor_f_wr_resp
  assign s_xactor_f_wr_resp_D_IN =
	     (i2c_user_ber ||
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h08 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h20 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h10 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h0 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h28 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h38 &&
	      s_xactor_f_wr_addr_D_OUT[12:5] != 8'h30) ?
	       2'd2 :
	       2'd0 ;
  assign s_xactor_f_wr_resp_ENQ =
	     CAN_FIRE_RL_write_request && !WILL_FIRE_RL_read_request ;
  assign s_xactor_f_wr_resp_DEQ =
	     slave_m_bready_bready && s_xactor_f_wr_resp_EMPTY_N ;
  assign s_xactor_f_wr_resp_CLR = 1'b0 ;

  // remaining internal signals
  assign IF_s_xactor_f_wr_data_first__56_BITS_6_TO_5_57_ETC___d278 =
	     (s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	      (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12) &&
	      !i2c_user_bb) ?
	       5'd4 :
	       5'd15 ;
  assign NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d128 =
	     x__h3214 != 2'd1 &&
	     (i2c_user_s3 == 8'h0A || !i2c_user_val_SCL ||
	      !i2c_user_operation) ;
  assign NOT_i2c_user_sta_1_CONCAT_i2c_user_sto_2_3_EQ__ETC___d139 =
	     x__h3214 != 2'd1 && i2c_user_s3 != 8'h0A && i2c_user_operation &&
	     !i2c_user_ack ;
  assign _0b110__q2 = 3'b110 ;
  assign _0b1__q3 = 3'b001 ;
  assign b__h7832 =
	     { r1__read__h8341,
	       1'd0,
	       r1__read__h8341,
	       1'd0,
	       r1__read__h8341,
	       1'd0,
	       r1__read__h8341,
	       1'd0 } ;
  assign b__h7839 =
	     { r1__read__h8928,
	       i2c_user_bb,
	       r1__read__h8928,
	       i2c_user_bb,
	       r1__read__h8928,
	       i2c_user_bb,
	       r1__read__h8928,
	       i2c_user_bb } ;
  assign b__h7846 = {4{i2c_user_s01}} ;
  assign b__h7853 = {4{i2c_user_s0}} ;
  assign b__h7860 = {4{i2c_user_s2}} ;
  assign b__h7867 = {4{i2c_user_s3}} ;
  assign b__h7874 = {2{i2c_user_i2ctime}} ;
  assign i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101 =
	     i2c_user_i2ctimeout <= i2c_user_i2ctime[13:0] ;
  assign i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d125 =
	     i2c_user_pin && x__h3214 != 2'd2 &&
	     (x__h3214 == 2'd1 || i2c_user_s3 == 8'h0A ||
	      !i2c_user_operation) ;
  assign i2c_user_pin_3_AND_NOT_i2c_user_sta_1_CONCAT_i_ETC___d133 =
	     i2c_user_pin && x__h3214 != 2'd2 && x__h3214 != 2'd1 &&
	     (i2c_user_s3 == 8'h0A || !i2c_user_operation) ;
  assign i2c_user_pin_3_AND_i2c_user_sta_1_CONCAT_i2c_u_ETC___d115 =
	     i2c_user_pin &&
	     (x__h3214 == 2'd2 || x__h3214 == 2'd1 || i2c_user_s3 == 8'h0A ||
	      !i2c_user_val_SCL ||
	      !i2c_user_operation) ||
	     !i2c_user_pin &&
	     i2c_user_i2ctimeout_7_ULE_i2c_user_i2ctime_4_B_ETC___d101 ;
  assign r1__read__h8341 = { r1__read__h8343, 1'd0 } ;
  assign r1__read__h8343 = { r1__read__h8345, 1'd0 } ;
  assign r1__read__h8345 = { r1__read__h8347, 1'd0 } ;
  assign r1__read__h8347 = { r1__read__h8349, 1'd0 } ;
  assign r1__read__h8349 = { r1__read__h8351, 1'd0 } ;
  assign r1__read__h8351 = { i2c_user_pin, 1'd0 } ;
  assign r1__read__h8928 = { r1__read__h8930, i2c_user_lab } ;
  assign r1__read__h8930 = { r1__read__h8932, i2c_user_aas } ;
  assign r1__read__h8932 = { r1__read__h8934, i2c_user_ad0_lrb } ;
  assign r1__read__h8934 = { r1__read__h8936, i2c_user_ber } ;
  assign r1__read__h8936 = { r1__read__h8938, i2c_user_sts } ;
  assign r1__read__h8938 = { i2c_user_pin, i2c_user_zero } ;
  assign s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d274 =
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ||
	     (s_xactor_f_wr_addr_D_OUT[12:5] == 8'h0 ||
	      s_xactor_f_wr_addr_D_OUT[12:5] == 8'h38) &&
	     !i2c_user_eso ;
  assign s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d283 =
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12 ||
	      s_xactor_f_wr_data_D_OUT[6:5] != 2'd2 ||
	      i2c_user_bb) ;
  assign s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d300 =
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     (i2c_user_mTransFSM == 5'd6 || i2c_user_mTransFSM == 5'd12) &&
	     !i2c_user_bb ;
  assign s_xactor_f_wr_addr_first__53_BITS_12_TO_5_54_E_ETC___d303 =
	     s_xactor_f_wr_addr_D_OUT[12:5] == 8'h08 &&
	     i2c_user_mTransFSM != 5'd6 &&
	     i2c_user_mTransFSM != 5'd12 &&
	     s_xactor_f_wr_data_D_OUT[6:5] == 2'd2 &&
	     !i2c_user_bb ;
  assign x__h14021 = ~i2c_user_pin ;
  assign x__h2667 = i2c_user_cycwaste + 10'd1 ;
  assign x__h3214 = { i2c_user_sta, i2c_user_sto } ;
  assign x__h5910 = i2c_user_i2ctimeout + 14'd1 ;
  assign x__h6744 = i2c_user_s0[x__h6839[2:0]] ;
  assign x__h6819 = 8'd1 << x__h6839 ;
  assign x__h6839 = i2c_user_dataBit - 4'd1 ;
  assign x__h6890 = i2c_user_resetcount + 6'd1 ;
  assign y__h6860 = ~x__h6819 ;
  always@(s_xactor_f_rd_addr_D_OUT or
	  b__h7860 or
	  b__h7832 or
	  b__h7853 or
	  b__h7839 or b__h7846 or b__h7867 or b__h7874 or i2c_user_c_scl)
  begin
    case (s_xactor_f_rd_addr_D_OUT[12:5])
      8'h0:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7860;
      8'h08:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7832;
      8'h10:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7853;
      8'h18:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7839;
      8'h20:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7846;
      8'h28:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7867;
      8'h30:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      b__h7874;
      8'h38:
	  IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
	      i2c_user_c_scl;
      default: IF_s_xactor_f_rd_addr_first__79_BITS_12_TO_5_8_ETC___d246 =
		   32'd0;
    endcase
  end
  always@(x__h3214 or i2c_user_s3 or i2c_user_operation)
  begin
    case (x__h3214)
      2'd1: CASE_x214_1_15_2_9_IF_i2c_user_s3_EQ_0xA_THEN__ETC__q1 = 5'd15;
      2'd2: CASE_x214_1_15_2_9_IF_i2c_user_s3_EQ_0xA_THEN__ETC__q1 = 5'd9;
      default: CASE_x214_1_15_2_9_IF_i2c_user_s3_EQ_0xA_THEN__ETC__q1 =
		   (i2c_user_s3 == 8'h0A) ?
		     5'd5 :
		     (i2c_user_operation ? 5'd8 : 5'd7);
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        i2c_user_aas <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_ack <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_ad0_lrb <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_bb <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_ber <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_cOutEn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_c_scl <= `BSV_ASSIGNMENT_DELAY 32'd0;
	i2c_user_coSCL <= `BSV_ASSIGNMENT_DELAY 32'd0;
	i2c_user_configchange <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_cprescaler <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_cycwaste <= `BSV_ASSIGNMENT_DELAY 10'd0;
	i2c_user_dOutEn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_dataBit <= `BSV_ASSIGNMENT_DELAY 4'd8;
	i2c_user_drv0_rg <= `BSV_ASSIGNMENT_DELAY 8'd1;
	i2c_user_drv1_rg <= `BSV_ASSIGNMENT_DELAY 8'd1;
	i2c_user_drv2_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_eni <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_es1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_es2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_eso <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_i2ctime <= `BSV_ASSIGNMENT_DELAY 16'd0;
	i2c_user_i2ctimeout <= `BSV_ASSIGNMENT_DELAY 14'd1;
	i2c_user_lab <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_last_byte_read <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_mTransFSM <= `BSV_ASSIGNMENT_DELAY 5'd1;
	i2c_user_mod_start <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_operation <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_pd_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_pin <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_ppen_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_prg_slew_rg <= `BSV_ASSIGNMENT_DELAY 8'd1;
	i2c_user_puq_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_pwrup_pull_en_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_pwrupzhl_rg <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_reSCL <= `BSV_ASSIGNMENT_DELAY 32'd0;
	i2c_user_resetcount <= `BSV_ASSIGNMENT_DELAY 6'd0;
	i2c_user_rprescaler <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_rstsig <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_s01 <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i2c_user_s2 <= `BSV_ASSIGNMENT_DELAY 8'b11000000;
	i2c_user_s3 <= `BSV_ASSIGNMENT_DELAY 8'd9;
	i2c_user_scl_start <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_sendInd <= `BSV_ASSIGNMENT_DELAY 2'd2;
	i2c_user_st_toggle <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_sta <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_sto <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_sts <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i2c_user_val_SCL <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_val_SCL_in <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_val_SDA <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_val_SDA_in <= `BSV_ASSIGNMENT_DELAY 1'd1;
	i2c_user_zero <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (i2c_user_aas_EN)
	  i2c_user_aas <= `BSV_ASSIGNMENT_DELAY i2c_user_aas_D_IN;
	if (i2c_user_ack_EN)
	  i2c_user_ack <= `BSV_ASSIGNMENT_DELAY i2c_user_ack_D_IN;
	if (i2c_user_ad0_lrb_EN)
	  i2c_user_ad0_lrb <= `BSV_ASSIGNMENT_DELAY i2c_user_ad0_lrb_D_IN;
	if (i2c_user_bb_EN)
	  i2c_user_bb <= `BSV_ASSIGNMENT_DELAY i2c_user_bb_D_IN;
	if (i2c_user_ber_EN)
	  i2c_user_ber <= `BSV_ASSIGNMENT_DELAY i2c_user_ber_D_IN;
	if (i2c_user_cOutEn_EN)
	  i2c_user_cOutEn <= `BSV_ASSIGNMENT_DELAY i2c_user_cOutEn_D_IN;
	if (i2c_user_c_scl_EN)
	  i2c_user_c_scl <= `BSV_ASSIGNMENT_DELAY i2c_user_c_scl_D_IN;
	if (i2c_user_coSCL_EN)
	  i2c_user_coSCL <= `BSV_ASSIGNMENT_DELAY i2c_user_coSCL_D_IN;
	if (i2c_user_configchange_EN)
	  i2c_user_configchange <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_configchange_D_IN;
	if (i2c_user_cprescaler_EN)
	  i2c_user_cprescaler <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_cprescaler_D_IN;
	if (i2c_user_cycwaste_EN)
	  i2c_user_cycwaste <= `BSV_ASSIGNMENT_DELAY i2c_user_cycwaste_D_IN;
	if (i2c_user_dOutEn_EN)
	  i2c_user_dOutEn <= `BSV_ASSIGNMENT_DELAY i2c_user_dOutEn_D_IN;
	if (i2c_user_dataBit_EN)
	  i2c_user_dataBit <= `BSV_ASSIGNMENT_DELAY i2c_user_dataBit_D_IN;
	if (i2c_user_drv0_rg_EN)
	  i2c_user_drv0_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_drv0_rg_D_IN;
	if (i2c_user_drv1_rg_EN)
	  i2c_user_drv1_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_drv1_rg_D_IN;
	if (i2c_user_drv2_rg_EN)
	  i2c_user_drv2_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_drv2_rg_D_IN;
	if (i2c_user_eni_EN)
	  i2c_user_eni <= `BSV_ASSIGNMENT_DELAY i2c_user_eni_D_IN;
	if (i2c_user_es1_EN)
	  i2c_user_es1 <= `BSV_ASSIGNMENT_DELAY i2c_user_es1_D_IN;
	if (i2c_user_es2_EN)
	  i2c_user_es2 <= `BSV_ASSIGNMENT_DELAY i2c_user_es2_D_IN;
	if (i2c_user_eso_EN)
	  i2c_user_eso <= `BSV_ASSIGNMENT_DELAY i2c_user_eso_D_IN;
	if (i2c_user_i2ctime_EN)
	  i2c_user_i2ctime <= `BSV_ASSIGNMENT_DELAY i2c_user_i2ctime_D_IN;
	if (i2c_user_i2ctimeout_EN)
	  i2c_user_i2ctimeout <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_i2ctimeout_D_IN;
	if (i2c_user_lab_EN)
	  i2c_user_lab <= `BSV_ASSIGNMENT_DELAY i2c_user_lab_D_IN;
	if (i2c_user_last_byte_read_EN)
	  i2c_user_last_byte_read <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_last_byte_read_D_IN;
	if (i2c_user_mTransFSM_EN)
	  i2c_user_mTransFSM <= `BSV_ASSIGNMENT_DELAY i2c_user_mTransFSM_D_IN;
	if (i2c_user_mod_start_EN)
	  i2c_user_mod_start <= `BSV_ASSIGNMENT_DELAY i2c_user_mod_start_D_IN;
	if (i2c_user_operation_EN)
	  i2c_user_operation <= `BSV_ASSIGNMENT_DELAY i2c_user_operation_D_IN;
	if (i2c_user_pd_rg_EN)
	  i2c_user_pd_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_pd_rg_D_IN;
	if (i2c_user_pin_EN)
	  i2c_user_pin <= `BSV_ASSIGNMENT_DELAY i2c_user_pin_D_IN;
	if (i2c_user_ppen_rg_EN)
	  i2c_user_ppen_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_ppen_rg_D_IN;
	if (i2c_user_prg_slew_rg_EN)
	  i2c_user_prg_slew_rg <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_prg_slew_rg_D_IN;
	if (i2c_user_puq_rg_EN)
	  i2c_user_puq_rg <= `BSV_ASSIGNMENT_DELAY i2c_user_puq_rg_D_IN;
	if (i2c_user_pwrup_pull_en_rg_EN)
	  i2c_user_pwrup_pull_en_rg <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_pwrup_pull_en_rg_D_IN;
	if (i2c_user_pwrupzhl_rg_EN)
	  i2c_user_pwrupzhl_rg <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_pwrupzhl_rg_D_IN;
	if (i2c_user_reSCL_EN)
	  i2c_user_reSCL <= `BSV_ASSIGNMENT_DELAY i2c_user_reSCL_D_IN;
	if (i2c_user_resetcount_EN)
	  i2c_user_resetcount <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_resetcount_D_IN;
	if (i2c_user_rprescaler_EN)
	  i2c_user_rprescaler <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_rprescaler_D_IN;
	if (i2c_user_rstsig_EN)
	  i2c_user_rstsig <= `BSV_ASSIGNMENT_DELAY i2c_user_rstsig_D_IN;
	if (i2c_user_s01_EN)
	  i2c_user_s01 <= `BSV_ASSIGNMENT_DELAY i2c_user_s01_D_IN;
	if (i2c_user_s2_EN)
	  i2c_user_s2 <= `BSV_ASSIGNMENT_DELAY i2c_user_s2_D_IN;
	if (i2c_user_s3_EN)
	  i2c_user_s3 <= `BSV_ASSIGNMENT_DELAY i2c_user_s3_D_IN;
	if (i2c_user_scl_start_EN)
	  i2c_user_scl_start <= `BSV_ASSIGNMENT_DELAY i2c_user_scl_start_D_IN;
	if (i2c_user_sendInd_EN)
	  i2c_user_sendInd <= `BSV_ASSIGNMENT_DELAY i2c_user_sendInd_D_IN;
	if (i2c_user_st_toggle_EN)
	  i2c_user_st_toggle <= `BSV_ASSIGNMENT_DELAY i2c_user_st_toggle_D_IN;
	if (i2c_user_sta_EN)
	  i2c_user_sta <= `BSV_ASSIGNMENT_DELAY i2c_user_sta_D_IN;
	if (i2c_user_sto_EN)
	  i2c_user_sto <= `BSV_ASSIGNMENT_DELAY i2c_user_sto_D_IN;
	if (i2c_user_sts_EN)
	  i2c_user_sts <= `BSV_ASSIGNMENT_DELAY i2c_user_sts_D_IN;
	if (i2c_user_val_SCL_EN)
	  i2c_user_val_SCL <= `BSV_ASSIGNMENT_DELAY i2c_user_val_SCL_D_IN;
	if (i2c_user_val_SCL_in_EN)
	  i2c_user_val_SCL_in <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_val_SCL_in_D_IN;
	if (i2c_user_val_SDA_EN)
	  i2c_user_val_SDA <= `BSV_ASSIGNMENT_DELAY i2c_user_val_SDA_D_IN;
	if (i2c_user_val_SDA_in_EN)
	  i2c_user_val_SDA_in <= `BSV_ASSIGNMENT_DELAY
	      i2c_user_val_SDA_in_D_IN;
	if (i2c_user_zero_EN)
	  i2c_user_zero <= `BSV_ASSIGNMENT_DELAY i2c_user_zero_D_IN;
      end
    if (i2c_user_s0_EN) i2c_user_s0 <= `BSV_ASSIGNMENT_DELAY i2c_user_s0_D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    i2c_user_aas = 1'h0;
    i2c_user_ack = 1'h0;
    i2c_user_ad0_lrb = 1'h0;
    i2c_user_bb = 1'h0;
    i2c_user_ber = 1'h0;
    i2c_user_cOutEn = 1'h0;
    i2c_user_c_scl = 32'hAAAAAAAA;
    i2c_user_coSCL = 32'hAAAAAAAA;
    i2c_user_configchange = 1'h0;
    i2c_user_cprescaler = 8'hAA;
    i2c_user_cycwaste = 10'h2AA;
    i2c_user_dOutEn = 1'h0;
    i2c_user_dataBit = 4'hA;
    i2c_user_drv0_rg = 8'hAA;
    i2c_user_drv1_rg = 8'hAA;
    i2c_user_drv2_rg = 8'hAA;
    i2c_user_eni = 1'h0;
    i2c_user_es1 = 1'h0;
    i2c_user_es2 = 1'h0;
    i2c_user_eso = 1'h0;
    i2c_user_i2ctime = 16'hAAAA;
    i2c_user_i2ctimeout = 14'h2AAA;
    i2c_user_lab = 1'h0;
    i2c_user_last_byte_read = 1'h0;
    i2c_user_mTransFSM = 5'h0A;
    i2c_user_mod_start = 1'h0;
    i2c_user_operation = 1'h0;
    i2c_user_pd_rg = 8'hAA;
    i2c_user_pin = 1'h0;
    i2c_user_ppen_rg = 8'hAA;
    i2c_user_prg_slew_rg = 8'hAA;
    i2c_user_puq_rg = 8'hAA;
    i2c_user_pwrup_pull_en_rg = 8'hAA;
    i2c_user_pwrupzhl_rg = 8'hAA;
    i2c_user_reSCL = 32'hAAAAAAAA;
    i2c_user_resetcount = 6'h2A;
    i2c_user_rprescaler = 8'hAA;
    i2c_user_rstsig = 1'h0;
    i2c_user_s0 = 8'hAA;
    i2c_user_s01 = 8'hAA;
    i2c_user_s2 = 8'hAA;
    i2c_user_s3 = 8'hAA;
    i2c_user_scl_start = 1'h0;
    i2c_user_sendInd = 2'h2;
    i2c_user_st_toggle = 1'h0;
    i2c_user_sta = 1'h0;
    i2c_user_sto = 1'h0;
    i2c_user_sts = 1'h0;
    i2c_user_val_SCL = 1'h0;
    i2c_user_val_SCL_in = 1'h0;
    i2c_user_val_SDA = 1'h0;
    i2c_user_val_SDA_in = 1'h0;
    i2c_user_zero = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_set_scl_clock &&
	  WILL_FIRE_RL_i2c_user_restore_scl)
	$display("Error: \"devices/i2c//i2c.bsv\", line 368, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_set_scl_clock] and\n  [RL_i2c_user_restore_scl] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_set_scl_clock &&
	  WILL_FIRE_RL_i2c_user_count_scl)
	$display("Error: \"devices/i2c//i2c.bsv\", line 368, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_set_scl_clock] and\n  [RL_i2c_user_count_scl] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_count_scl &&
	  WILL_FIRE_RL_i2c_user_restore_scl)
	$display("Error: \"devices/i2c//i2c.bsv\", line 368, column 46: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_count_scl] and\n  [RL_i2c_user_restore_scl] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_send_addr &&
	  WILL_FIRE_RL_i2c_user_receive_data)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 52: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_send_addr] and\n  [RL_i2c_user_receive_data] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_check_Ack &&
	  WILL_FIRE_RL_i2c_user_receive_data)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 42: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_check_Ack] and\n  [RL_i2c_user_receive_data] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_check_Ack && WILL_FIRE_RL_i2c_user_send_addr)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 42: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_check_Ack] and\n  [RL_i2c_user_send_addr] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_check_Ack && WILL_FIRE_RL_i2c_user_send_data)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 42: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_check_Ack] and\n  [RL_i2c_user_send_data] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_send_data &&
	  WILL_FIRE_RL_i2c_user_receive_data)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_send_data] and\n  [RL_i2c_user_receive_data] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_send_data && WILL_FIRE_RL_i2c_user_send_addr)
	$display("Error: \"devices/i2c//i2c.bsv\", line 367, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_send_data] and\n  [RL_i2c_user_send_addr] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_i2c_user_check_control_reg &&
	  WILL_FIRE_RL_i2c_user_send_start_trans)
	$display("Error: \"devices/i2c//i2c.bsv\", line 451, column 32: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_i2c_user_check_control_reg]\n  and [RL_i2c_user_send_start_trans] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mki2c

