//
// Generated by Bluespec Compiler, version 2022.01-36-ga6304315 (build a6304315)
//
// On Tue Oct  4 10:37:07 CEST 2022
//
//
// Ports:
// Name                         I/O  size props
// inst_request_get               O    34
// RDY_inst_request_get           O     1
// RDY_inst_response_put          O     1 reg
// tx_stage1_operands_enq_ena     O     1
// tx_stage1_operands_enq_data    O    64
// tx_stage1_meta_enq_ena         O     1
// tx_stage1_meta_enq_data        O    62
// tx_stage1_control_enq_ena      O     1
// tx_stage1_control_enq_data     O    34 reg
// RDY_commit_rd_put              O     1
// RDY_ma_update_eEpoch           O     1 const
// RDY_ma_update_wEpoch           O     1 const
// mav_debug_access_gprs          O    32
// RDY_mav_debug_access_gprs      O     1
// resetpc                        I    32
// CLK                            I     1 clock
// RST_N                          I     1 reset
// inst_response_put              I    35 reg
// tx_stage1_operands_notFull_b   I     1 unused
// tx_stage1_operands_enq_rdy_b   I     1
// tx_stage1_meta_notFull_b       I     1 unused
// tx_stage1_meta_enq_rdy_b       I     1
// tx_stage1_control_notFull_b    I     1 unused
// tx_stage1_control_enq_rdy_b    I     1
// commit_rd_put                  I    37
// ma_flush_newpc                 I    32
// ma_csr_misa_c_c                I     1 unused
// ma_interrupt_i                 I     1
// ma_csr_decode_c                I   118
// mav_debug_access_gprs_cmd      I    47
// ma_debug_status_status         I     5
// EN_inst_response_put           I     1
// EN_commit_rd_put               I     1
// EN_ma_flush                    I     1
// EN_ma_update_eEpoch            I     1
// EN_ma_update_wEpoch            I     1
// EN_inst_request_get            I     1
// EN_mav_debug_access_gprs       I     1
//
// Combinational paths from inputs to outputs:
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_ma_flush) -> tx_stage1_operands_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    commit_rd_put,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_commit_rd_put,
//    EN_ma_flush) -> tx_stage1_operands_enq_data
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_ma_flush) -> tx_stage1_meta_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_ma_flush) -> tx_stage1_meta_enq_data
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_ma_flush) -> tx_stage1_control_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    ma_csr_decode_c,
//    ma_debug_status_status,
//    EN_ma_flush) -> tx_stage1_control_enq_data
//   mav_debug_access_gprs_cmd -> mav_debug_access_gprs
//
//
// module: This Module implements the instruction-fetch + decode + operand-fetch   functionality of the pipeline.     1. Instruction-Fetch phase:  It generates the new PC, sends the PC to the fabric and in   return expects the instruction response from the fabric. The PC is updated  either when a flush is received from any of the later stages or is simple incremented by 4 or 2  (in case of compressed instructions)    2. Decode phase: Once the instruction is received, it is checked if the instruction is a  compressed instruction or not. If so, then it passes through a decompressor which then converts  the compressed instruction into its 32-bit equivalent encoding. The 32-bit instructions are  then decoded to capture various informations. Most of the decoded information which holds  control-flow information is passed on to the next stage for execution.    3. Operand Fetch: The operand addresses are generated by the decoder and then used to access the  register file. The registerfile itself forward the data of the commit happening in the same  cycle. The fetched operands are then passed on to the next stage.    4. The debugger also is given access to the registerfile through this module.    5. Triggers are also supported to capture events related to program counter or instruction match
//
// Comments on the inlined module `wr_debug_info':
//   wire: This wire will capture info about the current debug state of the core
//
// Comments on the inlined module `integer_rf':
//   submod: operand register file
//
// Comments on the inlined module `wr_interrupt':
//   wire: This wire will be set if any interrupts have been detected by the core
//
// Comments on the inlined module `wr_csr_decode':
//   wire: this wire caries the current value of certain csrs
//
// Comments on the inlined module `wr_csr_misa_c':
//   wire: this wire carries the current value of the misa_c csr field
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkstage1(resetpc,
		CLK,
		RST_N,

		EN_inst_request_get,
		inst_request_get,
		RDY_inst_request_get,

		inst_response_put,
		EN_inst_response_put,
		RDY_inst_response_put,

		tx_stage1_operands_notFull_b,

		tx_stage1_operands_enq_rdy_b,

		tx_stage1_operands_enq_ena,

		tx_stage1_operands_enq_data,

		tx_stage1_meta_notFull_b,

		tx_stage1_meta_enq_rdy_b,

		tx_stage1_meta_enq_ena,

		tx_stage1_meta_enq_data,

		tx_stage1_control_notFull_b,

		tx_stage1_control_enq_rdy_b,

		tx_stage1_control_enq_ena,

		tx_stage1_control_enq_data,

		commit_rd_put,
		EN_commit_rd_put,
		RDY_commit_rd_put,

		ma_flush_newpc,
		EN_ma_flush,

		ma_csr_misa_c_c,

		ma_interrupt_i,

		ma_csr_decode_c,

		EN_ma_update_eEpoch,
		RDY_ma_update_eEpoch,

		EN_ma_update_wEpoch,
		RDY_ma_update_wEpoch,

		mav_debug_access_gprs_cmd,
		EN_mav_debug_access_gprs,
		mav_debug_access_gprs,
		RDY_mav_debug_access_gprs,

		ma_debug_status_status);
  input  [31 : 0] resetpc;
  input  CLK;
  input  RST_N;

  // actionvalue method inst_request_get
  input  EN_inst_request_get;
  output [33 : 0] inst_request_get;
  output RDY_inst_request_get;

  // action method inst_response_put
  input  [34 : 0] inst_response_put;
  input  EN_inst_response_put;
  output RDY_inst_response_put;

  // action method tx_stage1_operands_notFull
  input  tx_stage1_operands_notFull_b;

  // action method tx_stage1_operands_enq_rdy
  input  tx_stage1_operands_enq_rdy_b;

  // value method tx_stage1_operands_enq_ena
  output tx_stage1_operands_enq_ena;

  // value method tx_stage1_operands_enq_data
  output [63 : 0] tx_stage1_operands_enq_data;

  // action method tx_stage1_meta_notFull
  input  tx_stage1_meta_notFull_b;

  // action method tx_stage1_meta_enq_rdy
  input  tx_stage1_meta_enq_rdy_b;

  // value method tx_stage1_meta_enq_ena
  output tx_stage1_meta_enq_ena;

  // value method tx_stage1_meta_enq_data
  output [61 : 0] tx_stage1_meta_enq_data;

  // action method tx_stage1_control_notFull
  input  tx_stage1_control_notFull_b;

  // action method tx_stage1_control_enq_rdy
  input  tx_stage1_control_enq_rdy_b;

  // value method tx_stage1_control_enq_ena
  output tx_stage1_control_enq_ena;

  // value method tx_stage1_control_enq_data
  output [33 : 0] tx_stage1_control_enq_data;

  // action method commit_rd_put
  input  [36 : 0] commit_rd_put;
  input  EN_commit_rd_put;
  output RDY_commit_rd_put;

  // action method ma_flush
  input  [31 : 0] ma_flush_newpc;
  input  EN_ma_flush;

  // action method ma_csr_misa_c
  input  ma_csr_misa_c_c;

  // action method ma_interrupt
  input  ma_interrupt_i;

  // action method ma_csr_decode
  input  [117 : 0] ma_csr_decode_c;

  // action method ma_update_eEpoch
  input  EN_ma_update_eEpoch;
  output RDY_ma_update_eEpoch;

  // action method ma_update_wEpoch
  input  EN_ma_update_wEpoch;
  output RDY_ma_update_wEpoch;

  // actionvalue method mav_debug_access_gprs
  input  [46 : 0] mav_debug_access_gprs_cmd;
  input  EN_mav_debug_access_gprs;
  output [31 : 0] mav_debug_access_gprs;
  output RDY_mav_debug_access_gprs;

  // action method ma_debug_status
  input  [4 : 0] ma_debug_status_status;

  // signals for module outputs
  wire [63 : 0] tx_stage1_operands_enq_data;
  wire [61 : 0] tx_stage1_meta_enq_data;
  wire [33 : 0] inst_request_get, tx_stage1_control_enq_data;
  wire [31 : 0] mav_debug_access_gprs;
  wire RDY_commit_rd_put,
       RDY_inst_request_get,
       RDY_inst_response_put,
       RDY_ma_update_eEpoch,
       RDY_ma_update_wEpoch,
       RDY_mav_debug_access_gprs,
       tx_stage1_control_enq_ena,
       tx_stage1_meta_enq_ena,
       tx_stage1_operands_enq_ena;

  // inlined wires
  wire [31 : 0] rg_fabric_request_port0__write_1,
		rg_fabric_request_port1__read,
		rg_fabric_request_port1__write_1,
		rg_fabric_request_port2__read;
  wire integer_rf_wr_write_address_whas,
       integer_rf_wr_write_data_whas,
       rg_fabric_request_EN_port1__write;

  // register rg_action
  // reg: This register implements a simple state - machine which indicates how the     instruction should be extracted from the cache response.
  reg rg_action;
  wire rg_action_D_IN, rg_action_EN;

  // register rg_eEpoch
  // reg: holds the current epoch values controlled by the stage2.
  reg rg_eEpoch;
  wire rg_eEpoch_D_IN, rg_eEpoch_EN;

  // register rg_fabric_request
  // reg: register to hold the address of the next request to the fabric.
  reg [31 : 0] rg_fabric_request;
  wire [31 : 0] rg_fabric_request_D_IN;
  wire rg_fabric_request_EN;

  // register rg_index
  // reg: index into the Regfile during initialization sequence.
  reg [4 : 0] rg_index;
  wire [4 : 0] rg_index_D_IN;
  wire rg_index_EN;

  // register rg_initialize
  // reg: register to indicate that the RegFile is being initialized to all zeros
  reg rg_initialize;
  wire rg_initialize_D_IN, rg_initialize_EN;

  // register rg_pc
  // reg: register to hold the PC value of the instruction to be decoded.
  reg [31 : 0] rg_pc;
  reg [31 : 0] rg_pc_D_IN;
  wire rg_pc_EN;

  // register rg_step_done
  // reg: This register indicates when an instruction passed the decode stage after a     resume request is received while is step is set.
  reg rg_step_done;
  wire rg_step_done_D_IN, rg_step_done_EN;

  // register rg_wEpoch
  // reg: holds the current epoch values controlled by the stage3.
  reg rg_wEpoch;
  wire rg_wEpoch_D_IN, rg_wEpoch_EN;

  // register rg_wfi
  // reg: this is register it set to True when a WFI instruction is executed. It set to     False, when an interrupt has been received or there is a flush from the write - back stage.
  reg rg_wfi;
  wire rg_wfi_D_IN, rg_wfi_EN;

  // ports of submodule ff_memory_response
  wire [34 : 0] ff_memory_response_D_IN, ff_memory_response_D_OUT;
  wire ff_memory_response_CLR,
       ff_memory_response_DEQ,
       ff_memory_response_EMPTY_N,
       ff_memory_response_ENQ,
       ff_memory_response_FULL_N;

  // ports of submodule integer_rf_rf
  reg [31 : 0] integer_rf_rf_D_IN;
  reg [4 : 0] integer_rf_rf_ADDR_IN;
  wire [31 : 0] integer_rf_rf_D_OUT_1,
		integer_rf_rf_D_OUT_2,
		integer_rf_rf_D_OUT_3;
  wire [4 : 0] integer_rf_rf_ADDR_1,
	       integer_rf_rf_ADDR_2,
	       integer_rf_rf_ADDR_3,
	       integer_rf_rf_ADDR_4,
	       integer_rf_rf_ADDR_5;
  wire integer_rf_rf_WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_initialize_regfile,
       CAN_FIRE_RL_process_instruction,
       CAN_FIRE_RL_wait_for_interrupt,
       CAN_FIRE_commit_rd_put,
       CAN_FIRE_inst_request_get,
       CAN_FIRE_inst_response_put,
       CAN_FIRE_ma_csr_decode,
       CAN_FIRE_ma_csr_misa_c,
       CAN_FIRE_ma_debug_status,
       CAN_FIRE_ma_flush,
       CAN_FIRE_ma_interrupt,
       CAN_FIRE_ma_update_eEpoch,
       CAN_FIRE_ma_update_wEpoch,
       CAN_FIRE_mav_debug_access_gprs,
       CAN_FIRE_tx_stage1_control_enq_rdy,
       CAN_FIRE_tx_stage1_control_notFull,
       CAN_FIRE_tx_stage1_meta_enq_rdy,
       CAN_FIRE_tx_stage1_meta_notFull,
       CAN_FIRE_tx_stage1_operands_enq_rdy,
       CAN_FIRE_tx_stage1_operands_notFull,
       WILL_FIRE_RL_initialize_regfile,
       WILL_FIRE_RL_process_instruction,
       WILL_FIRE_RL_wait_for_interrupt,
       WILL_FIRE_commit_rd_put,
       WILL_FIRE_inst_request_get,
       WILL_FIRE_inst_response_put,
       WILL_FIRE_ma_csr_decode,
       WILL_FIRE_ma_csr_misa_c,
       WILL_FIRE_ma_debug_status,
       WILL_FIRE_ma_flush,
       WILL_FIRE_ma_interrupt,
       WILL_FIRE_ma_update_eEpoch,
       WILL_FIRE_ma_update_wEpoch,
       WILL_FIRE_mav_debug_access_gprs,
       WILL_FIRE_tx_stage1_control_enq_rdy,
       WILL_FIRE_tx_stage1_control_notFull,
       WILL_FIRE_tx_stage1_meta_enq_rdy,
       WILL_FIRE_tx_stage1_meta_notFull,
       WILL_FIRE_tx_stage1_operands_enq_rdy,
       WILL_FIRE_tx_stage1_operands_notFull;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_fabric_request_port1__write_1__VAL_2,
		MUX_rg_pc_write_1__VAL_1;
  wire MUX_integer_rf_rf_upd_1__SEL_2,
       MUX_rg_fabric_request_port1__write_1__SEL_1,
       MUX_rg_pc_write_1__SEL_1,
       MUX_rg_wfi_write_1__SEL_1;

  // remaining internal signals
  wire [61 : 0] decoder_func_32___d48;
  wire [31 : 0] decode_instruction__h2362,
		v__h2302,
		x__h2777,
		x__h2803,
		x__read__h987,
		x_wget__h976;
  wire [7 : 0] chk_interrupt___d39;
  wire [6 : 0] _theResult___fst__h2531,
	       func_cause___1__h2524,
	       x1_avValue_meta_funct__h2407;
  wire [4 : 0] x__read__h916, x_wget__h905;
  wire [2 : 0] IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50;
  wire [1 : 0] curr_epoch__h1934;
  wire rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30,
       rg_step_done__h2516;

  // actionvalue method inst_request_get
  assign inst_request_get = { rg_fabric_request, curr_epoch__h1934 } ;
  assign RDY_inst_request_get = !rg_initialize ;
  assign CAN_FIRE_inst_request_get = !rg_initialize ;
  assign WILL_FIRE_inst_request_get = EN_inst_request_get ;

  // action method inst_response_put
  assign RDY_inst_response_put = ff_memory_response_FULL_N ;
  assign CAN_FIRE_inst_response_put = ff_memory_response_FULL_N ;
  assign WILL_FIRE_inst_response_put = EN_inst_response_put ;

  // action method tx_stage1_operands_notFull
  assign CAN_FIRE_tx_stage1_operands_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_operands_notFull = 1'd1 ;

  // action method tx_stage1_operands_enq_rdy
  assign CAN_FIRE_tx_stage1_operands_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_operands_enq_rdy = 1'd1 ;

  // value method tx_stage1_operands_enq_ena
  assign tx_stage1_operands_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_operands_enq_data
  assign tx_stage1_operands_enq_data = { x__h2777, x__h2803 } ;

  // action method tx_stage1_meta_notFull
  assign CAN_FIRE_tx_stage1_meta_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_meta_notFull = 1'd1 ;

  // action method tx_stage1_meta_enq_rdy
  assign CAN_FIRE_tx_stage1_meta_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_meta_enq_rdy = 1'd1 ;

  // value method tx_stage1_meta_enq_ena
  assign tx_stage1_meta_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_meta_enq_data
  assign tx_stage1_meta_enq_data =
	     { decoder_func_32___d48[61:44],
	       IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50,
	       decoder_func_32___d48[40:7],
	       x1_avValue_meta_funct__h2407 } ;

  // action method tx_stage1_control_notFull
  assign CAN_FIRE_tx_stage1_control_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_control_notFull = 1'd1 ;

  // action method tx_stage1_control_enq_rdy
  assign CAN_FIRE_tx_stage1_control_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_control_enq_rdy = 1'd1 ;

  // value method tx_stage1_control_enq_ena
  assign tx_stage1_control_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_control_enq_data
  assign tx_stage1_control_enq_data = { curr_epoch__h1934, rg_pc } ;

  // action method commit_rd_put
  assign RDY_commit_rd_put = !rg_initialize ;
  assign CAN_FIRE_commit_rd_put = !rg_initialize ;
  assign WILL_FIRE_commit_rd_put = EN_commit_rd_put ;

  // action method ma_flush
  assign CAN_FIRE_ma_flush = 1'd1 ;
  assign WILL_FIRE_ma_flush = EN_ma_flush ;

  // action method ma_csr_misa_c
  assign CAN_FIRE_ma_csr_misa_c = 1'd1 ;
  assign WILL_FIRE_ma_csr_misa_c = 1'd1 ;

  // action method ma_interrupt
  assign CAN_FIRE_ma_interrupt = 1'd1 ;
  assign WILL_FIRE_ma_interrupt = 1'd1 ;

  // action method ma_csr_decode
  assign CAN_FIRE_ma_csr_decode = 1'd1 ;
  assign WILL_FIRE_ma_csr_decode = 1'd1 ;

  // action method ma_update_eEpoch
  assign RDY_ma_update_eEpoch = 1'd1 ;
  assign CAN_FIRE_ma_update_eEpoch = 1'd1 ;
  assign WILL_FIRE_ma_update_eEpoch = EN_ma_update_eEpoch ;

  // action method ma_update_wEpoch
  assign RDY_ma_update_wEpoch = 1'd1 ;
  assign CAN_FIRE_ma_update_wEpoch = 1'd1 ;
  assign WILL_FIRE_ma_update_wEpoch = EN_ma_update_wEpoch ;

  // actionvalue method mav_debug_access_gprs
  assign mav_debug_access_gprs = integer_rf_rf_D_OUT_3 ;
  assign RDY_mav_debug_access_gprs = !rg_initialize ;
  assign CAN_FIRE_mav_debug_access_gprs = !rg_initialize ;
  assign WILL_FIRE_mav_debug_access_gprs = EN_mav_debug_access_gprs ;

  // action method ma_debug_status
  assign CAN_FIRE_ma_debug_status = 1'd1 ;
  assign WILL_FIRE_ma_debug_status = 1'd1 ;

  // submodule ff_memory_response
  // fifo: to hold the instruction response from the fabric
  FIFO2 #(.width(32'd35), .guarded(1'd1)) ff_memory_response(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(ff_memory_response_D_IN),
							     .ENQ(ff_memory_response_ENQ),
							     .DEQ(ff_memory_response_DEQ),
							     .CLR(ff_memory_response_CLR),
							     .D_OUT(ff_memory_response_D_OUT),
							     .FULL_N(ff_memory_response_FULL_N),
							     .EMPTY_N(ff_memory_response_EMPTY_N));

  // submodule integer_rf_rf
  RegFile #(.addr_width(32'd5),
	    .data_width(32'd32),
	    .lo(5'd0),
	    .hi(5'd31)) integer_rf_rf(.CLK(CLK),
				      .ADDR_1(integer_rf_rf_ADDR_1),
				      .ADDR_2(integer_rf_rf_ADDR_2),
				      .ADDR_3(integer_rf_rf_ADDR_3),
				      .ADDR_4(integer_rf_rf_ADDR_4),
				      .ADDR_5(integer_rf_rf_ADDR_5),
				      .ADDR_IN(integer_rf_rf_ADDR_IN),
				      .D_IN(integer_rf_rf_D_IN),
				      .WE(integer_rf_rf_WE),
				      .D_OUT_1(integer_rf_rf_D_OUT_1),
				      .D_OUT_2(integer_rf_rf_D_OUT_2),
				      .D_OUT_3(integer_rf_rf_D_OUT_3),
				      .D_OUT_4(),
				      .D_OUT_5());

  // rule RL_initialize_regfile
  //   rule: initialize all the registers to 0 on reset
  assign CAN_FIRE_RL_initialize_regfile = rg_initialize ;
  assign WILL_FIRE_RL_initialize_regfile = rg_initialize ;

  // rule RL_wait_for_interrupt
  //   rule:This rule is fired when the core has executed the WFI instruction and waiting     for an intterupt to the core to resume fetch
  assign CAN_FIRE_RL_wait_for_interrupt = rg_wfi && !rg_initialize ;
  assign WILL_FIRE_RL_wait_for_interrupt =
	     CAN_FIRE_RL_wait_for_interrupt && !EN_ma_flush ;

  // rule RL_process_instruction
  //   rule:This rule will receive the instruction from the memory subsystem and decide if     the instruction is compressed or not. The final instruction is then sent to the next stage.    To extract the instruction from the memory response a state machine is implemented.        1. First the epochs are compared and if a mis - match is observed then the response is     dropped without any other changes to the state of the module.    2. if rg_discard is set and compressed is enabled then the lower 16 - bits of the    resposne are discarded and the upper 16 - bits are probed to check if it is a compressed    instruction. If so, then the instruction is sent to the next stage. However is it is not a    compressed instruction it means the upper 16 - bits of the response refer to the lower 16 -    bits of a 32 - bit instruction and thus we will have to wait for the next response from the     cache to form the instruction is send to the next stage. To ensure the concatenation happens     in the next response we set rg_action to ChecPrev and set enque_instruction to False.    3. if rg_action is set to None, then we simply probe the lower 2 - bits to the response to    check if it is compressed. If so then the lower 16 bits form an instruction which is sent to    the next stage, the upper 16 - bits are stored to rg_instruction and rg_action is set to    CheckPrev to ensure that in the next resposne we first probe rg_instruction.    4. if rg_Action if set to CheckPrev then we first probe the lower 2 - bits of the     rg_instruction which leads to two possibilities. Either rg_instruction could hold a    compressed instruction from the previous response, in which case the current memory response    is not dequed and rg_instruction is sent to the next stage. This can happen due to state - 3    mentioned above. The other possibility is that rg_instruction holds the lower 16 - bits of a    32 - bit isntruction, in which case we have concatenate the lower 16 - bits of the response     with rg_instruction and send to the next, and also store the upper 16 - bits of the response     into rg_instruction. rg_Action in this case will remain CheckPrev so that the upper bits of     this repsonse are probed in the next cycle.
  assign CAN_FIRE_RL_process_instruction =
	     ff_memory_response_EMPTY_N && tx_stage1_operands_enq_rdy_b &&
	     tx_stage1_meta_enq_rdy_b &&
	     tx_stage1_control_enq_rdy_b &&
	     !rg_wfi &&
	     !rg_initialize ;
  assign WILL_FIRE_RL_process_instruction =
	     CAN_FIRE_RL_process_instruction && !EN_ma_flush ;

  // inputs to muxes for submodule ports
  assign MUX_integer_rf_rf_upd_1__SEL_2 =
	     EN_mav_debug_access_gprs && mav_debug_access_gprs_cmd[46] ;
  assign MUX_rg_fabric_request_port1__write_1__SEL_1 =
	     rg_initialize && rg_index == 5'd31 ;
  assign MUX_rg_pc_write_1__SEL_1 =
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50 !=
	     3'd7 &&
	     rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 ;
  assign MUX_rg_wfi_write_1__SEL_1 =
	     WILL_FIRE_RL_wait_for_interrupt && ma_interrupt_i ;
  assign MUX_rg_fabric_request_port1__write_1__VAL_2 =
	     { ma_flush_newpc[31:2], 2'b0 } ;
  assign MUX_rg_pc_write_1__VAL_1 = rg_pc + 32'd4 ;

  // inlined wires
  assign integer_rf_wr_write_address_whas =
	     rg_initialize || EN_commit_rd_put ;
  assign integer_rf_wr_write_data_whas = EN_commit_rd_put || rg_initialize ;
  assign rg_fabric_request_port0__write_1 = rg_fabric_request + 32'd4 ;
  assign rg_fabric_request_port1__read =
	     EN_inst_request_get ?
	       rg_fabric_request_port0__write_1 :
	       rg_fabric_request ;
  assign rg_fabric_request_EN_port1__write =
	     rg_initialize && rg_index == 5'd31 || EN_ma_flush ;
  assign rg_fabric_request_port1__write_1 =
	     MUX_rg_fabric_request_port1__write_1__SEL_1 ?
	       resetpc :
	       MUX_rg_fabric_request_port1__write_1__VAL_2 ;
  assign rg_fabric_request_port2__read =
	     rg_fabric_request_EN_port1__write ?
	       rg_fabric_request_port1__write_1 :
	       rg_fabric_request_port1__read ;

  // register rg_action
  assign rg_action_D_IN = 1'd1 ;
  assign rg_action_EN =
	     WILL_FIRE_RL_process_instruction &&
	     !rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 ;

  // register rg_eEpoch
  assign rg_eEpoch_D_IN = ~rg_eEpoch ;
  assign rg_eEpoch_EN = EN_ma_update_eEpoch ;

  // register rg_fabric_request
  assign rg_fabric_request_D_IN = rg_fabric_request_port2__read ;
  assign rg_fabric_request_EN = 1'b1 ;

  // register rg_index
  assign rg_index_D_IN = rg_index + 5'd1 ;
  assign rg_index_EN = rg_initialize ;

  // register rg_initialize
  assign rg_initialize_D_IN = 1'd0 ;
  assign rg_initialize_EN = MUX_rg_fabric_request_port1__write_1__SEL_1 ;

  // register rg_pc
  always@(MUX_rg_pc_write_1__SEL_1 or
	  MUX_rg_pc_write_1__VAL_1 or
	  MUX_rg_fabric_request_port1__write_1__SEL_1 or
	  resetpc or EN_ma_flush or ma_flush_newpc)
  case (1'b1)
    MUX_rg_pc_write_1__SEL_1: rg_pc_D_IN = MUX_rg_pc_write_1__VAL_1;
    MUX_rg_fabric_request_port1__write_1__SEL_1: rg_pc_D_IN = resetpc;
    EN_ma_flush: rg_pc_D_IN = ma_flush_newpc;
    default: rg_pc_D_IN =
		 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
  endcase
  assign rg_pc_EN =
	     rg_initialize && rg_index == 5'd31 ||
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50 !=
	     3'd7 &&
	     rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 ||
	     EN_ma_flush ;

  // register rg_step_done
  assign rg_step_done_D_IN =
	     !ma_debug_status_status[3] && ma_debug_status_status[2] &&
	     ma_debug_status_status[4] ;
  assign rg_step_done_EN = MUX_rg_pc_write_1__SEL_1 ;

  // register rg_wEpoch
  assign rg_wEpoch_D_IN = ~rg_wEpoch ;
  assign rg_wEpoch_EN = EN_ma_update_wEpoch ;

  // register rg_wfi
  assign rg_wfi_D_IN = !MUX_rg_wfi_write_1__SEL_1 && !EN_ma_flush ;
  assign rg_wfi_EN =
	     WILL_FIRE_RL_wait_for_interrupt && ma_interrupt_i ||
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50 ==
	     3'd7 &&
	     rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 ||
	     EN_ma_flush ;

  // submodule ff_memory_response
  assign ff_memory_response_D_IN = inst_response_put ;
  assign ff_memory_response_ENQ = EN_inst_response_put ;
  assign ff_memory_response_DEQ = WILL_FIRE_RL_process_instruction ;
  assign ff_memory_response_CLR = 1'b0 ;

  // submodule integer_rf_rf
  assign integer_rf_rf_ADDR_1 = decoder_func_32___d48[56:52] ;
  assign integer_rf_rf_ADDR_2 = decoder_func_32___d48[61:57] ;
  assign integer_rf_rf_ADDR_3 = mav_debug_access_gprs_cmd[36:32] ;
  assign integer_rf_rf_ADDR_4 = 5'h0 ;
  assign integer_rf_rf_ADDR_5 = 5'h0 ;
  always@(rg_initialize or
	  rg_index or
	  MUX_integer_rf_rf_upd_1__SEL_2 or
	  mav_debug_access_gprs_cmd or EN_commit_rd_put or commit_rd_put)
  case (1'b1)
    rg_initialize: integer_rf_rf_ADDR_IN = rg_index;
    MUX_integer_rf_rf_upd_1__SEL_2:
	integer_rf_rf_ADDR_IN = mav_debug_access_gprs_cmd[36:32];
    EN_commit_rd_put: integer_rf_rf_ADDR_IN = commit_rd_put[36:32];
    default: integer_rf_rf_ADDR_IN = 5'bxxxxx /* unspecified value */ ;
  endcase
  always@(rg_initialize or
	  MUX_integer_rf_rf_upd_1__SEL_2 or
	  mav_debug_access_gprs_cmd or EN_commit_rd_put or commit_rd_put)
  case (1'b1)
    rg_initialize: integer_rf_rf_D_IN = 32'd0;
    MUX_integer_rf_rf_upd_1__SEL_2:
	integer_rf_rf_D_IN = mav_debug_access_gprs_cmd[31:0];
    EN_commit_rd_put: integer_rf_rf_D_IN = commit_rd_put[31:0];
    default: integer_rf_rf_D_IN =
		 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
  endcase
  assign integer_rf_rf_WE =
	     EN_mav_debug_access_gprs && mav_debug_access_gprs_cmd[46] ||
	     rg_initialize ||
	     EN_commit_rd_put ;

  // remaining internal signals
  module_chk_interrupt instance_chk_interrupt_0(.chk_interrupt_prv(ma_csr_decode_c[117:116]),
						.chk_interrupt_mstatus(ma_csr_decode_c[63:32]),
						.chk_interrupt_mip(ma_csr_decode_c[115:102]),
						.chk_interrupt_mie(ma_csr_decode_c[101:90]),
						.chk_interrupt_debug(ma_debug_status_status),
						.chk_interrupt_step_done(rg_step_done__h2516),
						.chk_interrupt(chk_interrupt___d39));
  module_decoder_func_32 instance_decoder_func_32_1(.decoder_func_32_inst(decode_instruction__h2362),
						    .decoder_func_32_csrs(ma_csr_decode_c),
						    .decoder_func_32(decoder_func_32___d48));
  assign IF_chk_interrupt_9_BIT_1_0_OR_ff_memory_respon_ETC___d50 =
	     (chk_interrupt___d39[1] || ff_memory_response_D_OUT[0]) ?
	       3'd6 :
	       decoder_func_32___d48[43:41] ;
  assign _theResult___fst__h2531 =
	     ff_memory_response_D_OUT[0] ? 7'd1 : decoder_func_32___d48[6:0] ;
  assign curr_epoch__h1934 = { rg_eEpoch, rg_wEpoch } ;
  assign decode_instruction__h2362 =
	     rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 ?
	       v__h2302 :
	       32'd0 ;
  assign func_cause___1__h2524 = { 1'd0, chk_interrupt___d39[7:2] } ;
  assign rg_eEpoch_5_CONCAT_rg_wEpoch_6_7_EQ_ff_memory__ETC___d30 =
	     curr_epoch__h1934 == ff_memory_response_D_OUT[2:1] ;
  assign rg_step_done__h2516 = rg_step_done ;
  assign v__h2302 =
	     (ff_memory_response_D_OUT[4:3] == 2'b11) ?
	       ff_memory_response_D_OUT[34:3] :
	       32'd0 ;
  assign x1_avValue_meta_funct__h2407 =
	     chk_interrupt___d39[1] ?
	       func_cause___1__h2524 :
	       _theResult___fst__h2531 ;
  assign x__h2777 =
	     (decoder_func_32___d48[61:57] == x__read__h916) ?
	       x__read__h987 :
	       integer_rf_rf_D_OUT_2 ;
  assign x__h2803 =
	     (decoder_func_32___d48[56:52] == x__read__h916) ?
	       x__read__h987 :
	       integer_rf_rf_D_OUT_1 ;
  assign x__read__h916 =
	     integer_rf_wr_write_address_whas ? x_wget__h905 : 5'd0 ;
  assign x__read__h987 =
	     integer_rf_wr_write_data_whas ? x_wget__h976 : 32'd0 ;
  assign x_wget__h905 = rg_initialize ? rg_index : commit_rd_put[36:32] ;
  assign x_wget__h976 = EN_commit_rd_put ? commit_rd_put[31:0] : 32'd0 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_action <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_eEpoch <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_fabric_request <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_index <= `BSV_ASSIGNMENT_DELAY 5'd0;
	rg_initialize <= `BSV_ASSIGNMENT_DELAY 1'd1;
	rg_pc <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_step_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_wEpoch <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_wfi <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_action_EN) rg_action <= `BSV_ASSIGNMENT_DELAY rg_action_D_IN;
	if (rg_eEpoch_EN) rg_eEpoch <= `BSV_ASSIGNMENT_DELAY rg_eEpoch_D_IN;
	if (rg_fabric_request_EN)
	  rg_fabric_request <= `BSV_ASSIGNMENT_DELAY rg_fabric_request_D_IN;
	if (rg_index_EN) rg_index <= `BSV_ASSIGNMENT_DELAY rg_index_D_IN;
	if (rg_initialize_EN)
	  rg_initialize <= `BSV_ASSIGNMENT_DELAY rg_initialize_D_IN;
	if (rg_pc_EN) rg_pc <= `BSV_ASSIGNMENT_DELAY rg_pc_D_IN;
	if (rg_step_done_EN)
	  rg_step_done <= `BSV_ASSIGNMENT_DELAY rg_step_done_D_IN;
	if (rg_wEpoch_EN) rg_wEpoch <= `BSV_ASSIGNMENT_DELAY rg_wEpoch_D_IN;
	if (rg_wfi_EN) rg_wfi <= `BSV_ASSIGNMENT_DELAY rg_wfi_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_action = 1'h0;
    rg_eEpoch = 1'h0;
    rg_fabric_request = 32'hAAAAAAAA;
    rg_index = 5'h0A;
    rg_initialize = 1'h0;
    rg_pc = 32'hAAAAAAAA;
    rg_step_done = 1'h0;
    rg_wEpoch = 1'h0;
    rg_wfi = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkstage1

